[{"path":"https://codex.nimahejazi.org/haldensify/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to haldensify development","title":"Contributing to haldensify development","text":", authors haldensify R package, use guide used contributing development popular tidyverse ecosystem R packages. document simply formal re-statement fact. goal guide help get contributing haldensify quickly possible. guide divided two main pieces: Filing bug report feature request issue. Suggesting change via pull request.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contributing to haldensify development","text":"filing issue, important thing include minimal reproducible example can quickly verify problem, figure fix . three things need include make example reproducible: required packages, data, code. Packages loaded top script, ’s easy see ones example needs. easiest way include data use dput() generate R code recreate . Spend little bit time ensuring code easy others read: make sure ’ve used spaces variable names concise, informative use comments indicate problem lies best remove everything related problem. shorter code , easier understand. can check actually made reproducible example starting fresh R session pasting script . (Unless ’ve specifically asked , please don’t include output sessionInfo().)","code":""},{"path":"https://codex.nimahejazi.org/haldensify/CONTRIBUTING.html","id":"pull-requests","dir":"","previous_headings":"","what":"Pull requests","title":"Contributing to haldensify development","text":"contribute change haldensify, follow steps: Create branch git make changes. Push branch GitHub issue pull request (PR). Discuss pull request. Iterate either accept PR decide ’s good fit haldensify. steps described detail . might feel overwhelming first time get set , gets easier practice. ’re familiar git GitHub, please start reading http://r-pkgs..co.nz/git.html Pull requests evaluated checklist: Motivation. pull request clearly concisely motivates need change. Please describe problem PR addresses show pull request solves concisely possible. Also include motivation NEWS new release haldensify comes ’s easy users see ’s changed. Add item top file use markdown formatting. news item end (@yourGithubUsername, #the_issue_number). related changes. submit pull request, please check make sure haven’t accidentally included unrelated changes. make harder see exactly ’s changed, evaluate unexpected side effects. PR corresponds git branch, expect submit multiple changes make sure create multiple branches. multiple changes depend , start first one don’t submit others first one processed. Use haldensify coding style. , please follow official tidyverse style guide. Maintaining consistent style across whole code base makes much easier jump code. ’re modifying existing haldensify code doesn’t follow style guide, separate pull request fix style greatly appreciated. ’re adding new parameters new function, ’ll also need document roxygen2. Make sure re-run devtools::document() code submitting. seems like lot work don’t worry pull request isn’t perfect. ’s learning process. pull request process, unless ’ve submitted past ’s unlikely pull request accepted . Please don’t submit pull requests change existing behaviour. Instead, think can add new feature minimally invasive way.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2019-2025 Nima Hejazi Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/TODO.html","id":null,"dir":"","previous_headings":"","what":"haldensify development notes","title":"haldensify development notes","text":"Add ... args haldensify() allow arbitrary arguments passed directly fit_hal(). Remove use_future argument haldensify(), instead reducing calling future_mapply(), sequential evaluation via plan(sequential). Add example working bootstrap samples, e.g., using rsample. Add plot() method easily visualize empirical risk changes across sequence explored regularization parameter values. Add ipw_shift() function constructing IPW estimators mean counterfactual outcome stochastic shift intervention via haldensify. Add argument haldensify() allow normalization density estimates improve estimation stability. Note normalized density actually g(|W)/g(), instead currently estimated g(|W).","code":""},{"path":"https://codex.nimahejazi.org/haldensify/articles/intro_haldensify.html","id":"background-and-motivation","dir":"Articles","previous_headings":"","what":"Background and motivation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"causal inference problems, classical estimators (e.g., inverse probability weighting) doubly robust estimators (e.g., one-step estimation, targeted minimum loss estimation) require estimation propensity score, nuisance parameter corresponding treatment mechanism. treatments interest may often continuous-valued, approaches opt discretize treatment estimate effects based binary (categorical) treatment. simplifications often motivated convenience rather science – avoid estimation generalized propensity score (Hirano Imbens 2004; Imai Van Dyk 2004), covariate-conditional treatment density. haldensify package introduces flexible approach estimating conditional density functions, using highly adaptive lasso (HAL), nonparametric estimator shown exhibit desirable rate-convergence properties. Consider data generated typical cohort sampling O=(W,,Y)O = (W, , Y), WW vector baseline covariates, AA continuous (ordinal) treatment, YY outcome interest. Estimation generalized propensity score g0,Ag_{0,} corresponds estimating conditional density AA given W=wW = w. simple strategy estimating nuisance function assume parametric working model use parametric regression generate suitable density estimates. example, one operate working assumption AA given WW follows Gaussian distribution homoscedastic variance mean ∑j=1pβjϕj(W)\\sum_{j=1}^p \\beta_j \\phi_j(W), ϕ=(ϕj:j)\\phi = (\\phi_j : j) user-selected basis functions β=(βj:j)\\beta = (\\beta_j : j) unknown regression parameters. case, density estimate generated fitting linear regression AA ϕ(W)\\phi(W) estimate conditional mean AA given WW, paired maximum likelihood estimation variance AA. , estimated conditional density given density Gaussian distribution evaluated estimates. Unfortunately, approaches allow flexible modeling g0,Ag_{0,}. motivated development novel flexible procedure constructing conditional density estimators gn,(∣w)g_{n,}(\\mid w) AA given W=wW = w (possibly subject observation-level weights).","code":""},{"path":"https://codex.nimahejazi.org/haldensify/articles/intro_haldensify.html","id":"conditional-density-estimation-by-pooled-hazards-regression","dir":"Articles","previous_headings":"","what":"Conditional density estimation by pooled hazards regression","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"consistent estimation generalized propensity score integral part constructing estimators causal effects continuous treatments, conditional density estimator, built around HAL regression function, may quite useful flexibly constructing estimates. note proposals data adaptive estimation quantities sparse literature (e.g., Zhu, Coffman, Ghosh (2015)). Notably, Dı́az van der Laan (2011) gave proposal constructing semiparametric estimator target quantity based exploiting relationship hazard density functions. proposal builds upon several key ways: adjust algorithm incorporate sample-level weights, necessary making use sample-level weights (e.g., inverse probability censoring weighting); replace use arbitrary classification model HAL regression function. first modification general may applied estimation strategy Dı́az van der Laan (2011), latter contribution requires adjusting penalization aspect HAL regression respect use loss function appropriate density estimation hazard scale. build estimator conditional density, Dı́az van der Laan (2011) considered discretizing observed ∈Aa \\based number bins TT binning procedure (e.g., including number points bin forcing bins length). note choice tuning parameter TT corresponds roughly choice bandwidth classical kernel density estimation; made clear upon examination proposed algorithm. data {,W}\\{, W\\} reformatted hazard observed value ∈Aa \\falling given bin may evaluated via standard classification techniques. fact, proposal may viewed re-formulation classification problem corresponding set hazard regressions: ℙ(∈[αt−1,αt)∣W)=ℙ(∈[αt−1,αt)∣≥αt−1,W)×∏j=1t−1{1−ℙ(∈[αj−1,αj)∣≥αj−1,W)},\\begin{align*}    \\mathbb{P} (\\[\\alpha_{t-1}, \\alpha_t) \\mid W) =& \\mathbb{P} (\\   [\\alpha_{t-1}, \\alpha_t) \\mid \\geq \\alpha_{t-1}, W) \\times  \\\\ &    \\prod_{j = 1}^{t -1} \\{1 - \\mathbb{P} (\\[\\alpha_{j-1}, \\alpha_j)    \\mid \\geq \\alpha_{j-1}, W) \\}, \\end{align*} probability value ∈Aa \\falls bin [αt−1,αt)[\\alpha_{t-1}, \\alpha_t) may directly estimated standard classification model. likelihood model may re-expressed terms likelihood binary variable data set expressed repeated measures structure. Specifically, re-formatting procedure carried creating data set given observation AiA_i appears (repeatedly) many intervals [αt−1,αt)[\\alpha_{t-1}, \\alpha_t) prior interval observed aa belongs. new binary outcome variable, indicating Ai∈[αt−1,αt)A_i \\[\\alpha_{t-1}, \\alpha_t), recorded part new data structure. re-formatted data, pooled hazard regression, spanning support AA executed. Finally, conditional density estimator gn,α(∣W)=ℙ(∈[αt−1,αt)∣W)(αt−αt−1),\\begin{equation*}    g_{n, \\alpha}(\\mid W) = \\frac{\\mathbb{P}(\\[\\alpha_{t-1}, \\alpha_t)       \\mid W)}{(\\alpha_t - \\alpha_{t-1})}, \\end{equation*} αt−1≤≤αt\\alpha_{t-1} \\leq \\le \\alpha_t, may constructed. part procedure, hazard estimates mapped density estimates rescaling estimates bin size (αt−αt−1\\alpha_t - \\alpha_{t-1}). original proposal, key element procedure use arbitrary classification procedure estimating ℙ(∈[αt−1,αt)∣W)\\mathbb{P}(\\[\\alpha_{t-1}, \\alpha_t) \\mid W), facilitating incorporation flexible, data adaptive estimators. alter proposal two ways, replacing arbitrary estimator ℙ(∈[αt−1,αt)∣W)\\mathbb{P}(\\[\\alpha_{t-1}, \\alpha_t) \\mid W) HAL regression, accommodating use sample-level weights, making possible resultant conditional density estimator achieve convergence rate respect loss-based dissimilarity ≈n−1/3\\approx n^{-1/3} assumptions. procedure alters HAL regression function use loss function tailored estimation hazard, invoking ℓ1\\ell_1-penalization manner consistent loss.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/articles/intro_haldensify.html","id":"example-conditional-density-estimation","dir":"Articles","previous_headings":"","what":"Example: Conditional density estimation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"First, let’s load required packages set seed example. Next, ’ll generate simple simulated dataset. function make_example_data, defined , generates baseline covariate WW continuous treatment AA, whose mean function WW. Now, let’s simulate data take quick look : Next, ’ll fit pooled hazards conditional density estimator via haldensify wrapper function. Based underlying theory simulation experiments, recommend setting relatively large number bins using binning strategy accommodates creating large number bins. constructed conditional density estimator, can examine empirical risk grid choices L1L_1 regularization parameter λ\\lambda. , can simply call available plot method, uses cross-validated conditional density fits cv_tuning_results slot haldensify object. example,  Finally, can predict conditional density grid observed values AA across different elements support WW. using predict method haldensify plot results .  example, generate synthetic data along grid AA three values WW (W∈{−2,0,+2}W \\\\{-2, 0, +2\\}), representing distinct groups/strata respect covariate WW. Using data, use trained haldensify model predict density AA, conditional paired value WW, yielding estimates conditional density three hypothetical strata WW. resultant figure depicts estimated conditional density colored points (blue W=−2W = -2, green W=0W = 0, red W=+2W = +2), theoretical density group smooth curves (using ggplot2’s stat_function()). group, differences estimated conditional densities theoretical densities can taken indicative quality haldensify estimator example. Overall, haldensify estimator appears recover underlying density AA best group W=0W = 0, slightly degraded performance W=−2W = -2, degrades W=+2W = +2. haldensify conditional density estimator used estimate generalized propensity score applications methodology described Hejazi et al. (2020).","code":"library(haldensify) library(data.table) library(ggplot2) set.seed(75681) make_example_data <- function(n_obs) {   W <- runif(n_obs, -4, 4)   A <- rnorm(n_obs, mean = W, sd = 0.25)   dat <- as.data.table(list(A = A, W = W))   return(dat) } # number of observations in our simulated dataset n_obs <- 200 (example_data <- make_example_data(n_obs)) ##               A           W ##           <num>       <num> ##   1:  2.3063922  2.24687273 ##   2:  0.9297479  0.91025531 ##   3: -3.2443382 -2.98696024 ##   4: -0.1842217 -0.01204378 ##   5:  3.2756387  3.59166824 ##  ---                        ## 196:  0.4250425  0.43070281 ## 197:  1.0606211  1.35836156 ## 198:  2.2820014  2.34814939 ## 199: -2.9015290 -3.05240270 ## 200: -3.2334017 -3.52716556 haldensify_fit <- haldensify(   A = example_data$A,   W = example_data$W,   n_bins = c(4, 6, 8),   grid_type = \"equal_range\",   lambda_seq = exp(seq(-0.1, -10, length = 300)),   # the following are passed to hal9001::fit_hal() internally   max_degree = 1,   reduce_basis = 1 / sqrt(n_obs) ) p_risk <- plot(haldensify_fit) p_risk # predictions to recover conditional density of A|W new_a <- seq(-4, 4, by = 0.05) new_dat <- as.data.table(list(   a = new_a,   w_neg = rep(-2, length(new_a)),   w_zero = rep(0, length(new_a)),   w_pos = rep(2, length(new_a)) )) new_dat[, pred_w_neg := predict(haldensify_fit,   new_A = new_dat$a,   new_W = new_dat$w_neg )] new_dat[, pred_w_zero := predict(haldensify_fit,   new_A = new_dat$a,   new_W = new_dat$w_zero )] new_dat[, pred_w_pos := predict(haldensify_fit,   new_A = new_dat$a,   new_W = new_dat$w_pos )] # visualize results dens_dat <- melt(new_dat,   id = c(\"a\"),   measure.vars = c(\"pred_w_pos\", \"pred_w_zero\", \"pred_w_neg\") ) p_dens <- ggplot(dens_dat, aes(x = a, y = value, colour = variable)) +   geom_point() +   geom_line() +   stat_function(     fun = dnorm, args = list(mean = -2, sd = 0.25),     colour = \"blue\", linetype = \"dashed\"   ) +   stat_function(     fun = dnorm, args = list(mean = 0, sd = 0.25),     colour = \"darkgreen\", linetype = \"dashed\"   ) +   stat_function(     fun = dnorm, args = list(mean = 2, sd = 0.25),     colour = \"red\", linetype = \"dashed\"   ) +   labs(     x = \"Observed value of W\",     y = \"Estimated conditional density\",     title = \"Conditional density estimates g(A|W)\"   ) +   theme_bw() +   theme(legend.position = \"none\") p_dens"},{"path":"https://codex.nimahejazi.org/haldensify/articles/intro_haldensify.html","id":"nonparametric-inverse-probability-weighted-estimation","dir":"Articles","previous_headings":"","what":"Nonparametric inverse probability weighted estimation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"mentioned , generalized propensity score critical ingredient evaluating causal effects continuous treatments. popular framework defining evaluating causal effects modified treatment policies (Haneuse Rotnitzky 2013; Dı́az van der Laan 2018; Hejazi et al. 2022), define interventions shift (modify) treatment. example, setting continuous treatment AA, additionally collect baseline covariates WW outcome measurement YY (data given unit O=(W,,Y)O = (W, , Y)), consider intervention sets value AA via d(,W;δ)=+δ(W)d(,W; \\delta) = + \\delta(W), user-defined function d(,W;δ)d(,W;\\delta) indexed function (scalar) δ\\delta. intervention regime simple example modified treatment policy (MTP); can thought mapping observed AA counterfactual AδA_{\\delta} additive shift natural value AA. counterfactual mean intervention expressed 𝔼[Y(Aδ)]\\mathbb{E}[Y(A_{\\delta})], Y(Aδ)Y(A_{\\delta}) potential outcome observed treatment taken value AδA_{\\delta}. Haneuse Rotnitzky (2013) Dı́az van der Laan (2018) proposed substitution, inverse probability weighted (IPW), doubly robust estimators statistical functional ψ\\psi identifies counterfactual mean standard assumptions. Doubly robust estimators ψ\\psi implemented txshift R package (Hejazi Benkeser 2020, 2022); estimation frameworks usually necessary order take advantage flexible estimators nuisance parameters. Despite popularity doubly robust estimation procedures, IPW estimators can modified accommodate data adaptive estimation (generalized) propensity score. nonparametric IPW estimators, based HAL, described Ertefaie, Hejazi, van der Laan (2022) context binary treatments, Hejazi et al. (2022) continuous treatments. IPW estimator ψ\\psi ψn,IPW={g̃n,(∣W)/gn,(∣W)}Y\\psi_{n,\\text{IPW}} = \\{\\tilde{g}_{n,}(\\mid W) / g_{n,}(\\mid W)\\} Y, gn,Ag_{n,} estimator generalized propensity score (e.g., produced haldensify()) g̃n,\\tilde{g}_{n,} quantity evaluated post-intervention value treatment AδA_{\\delta}. Usually, gn,Ag_{n,} must estimated via parametric modeling strategies order ψn,IPW\\psi_{n,\\text{IPW}} achieve desirable asymptotic properties (unbiasedness, efficiency); however, gn,Ag_{n,} estimated flexibly, sieve estimation strategies (undersmoothing) may used select estimator gn,Ag_{n,}, among appropriate class, allows optimal estimation ψ\\psi. issue arises part strategies optimal selection gn,Ag_{n,} (e.g., cross-validation) optimize estimation conditional density, ignoring fact nuisance parameter process IPW estimation. haldensify() used purpose, family conditional density estimators gn,,λg_{n,,\\lambda}, indexed ℓ1\\ell_1 regularization term λ\\lambda, generated, cross-validation used select optimal estimator among trajectory λ\\lambda. saw visualized empirical risk profile gn,Ag_{n,}. empirical risk minimization based framework cross-validated loss-based estimation appropriate optimally estimating generalized propensity score, selected estimator fail yield IPW estimator desirable asymptotic properties; undersmoothing must used select appropriate estimator. haldensify package implements nonparametric IPW estimators incorporate undersmoothing ipw_shift() function, use demonstrate .","code":""},{"path":"https://codex.nimahejazi.org/haldensify/articles/intro_haldensify.html","id":"example-nonparametric-ipw-estimation","dir":"Articles","previous_headings":"","what":"Example: Nonparametric IPW estimation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"begin, set new data-generating process simulate data n=200n = 200 units . aim estimate counterfactual mean YY MTP shifts AA δ=2\\delta = 2. dataset, can now simply call ipw_shift() function, providing arguments specify causal effect interest (delta = 2) tuning parameters estimating generalized propensity score (lambda_seq, cv_folds, n_bins). selector_type argument specifies type undersmoothing used select appropriate IPW estimator (among sequence λ\\lambda); setting option selector_type = \"\" simply returns IPW estimators selectors implemented. formal description selectors numerical experiments examining performance, see Hejazi et al. (2022). confint() method used simply creates confidence intervals (95%, default) IPW estimates returned. Examining output, can see IPW estimator based cross-validation (\"gcv\") differs based minimization important criterion semiparametric efficiency theory (\"dcar_min\"). estimators different asymptotic properties, latter guaranteed solve estimating function required characterization asymptotically efficient estimators.","code":"# set up data-generating process make_example_data <- function(n_obs) {   W <- runif(n_obs, 1, 4)   A <- rpois(n_obs, 2 * W + 1)   Y <- rbinom(n_obs, 1, plogis(2 - A + W + 3))   dat <- as.data.table(list(Y = Y, A = A, W = W))   return(dat) }  # generate data and take a look (dat_obs <- make_example_data(n_obs = 200)) ##          Y     A        W ##      <int> <int>    <num> ##   1:     0    11 2.817789 ##   2:     1     7 3.086448 ##   3:     1     2 1.411537 ##   4:     1     6 2.913294 ##   5:     1     5 3.374974 ##  ---                      ## 196:     1     2 1.347253 ## 197:     1     3 1.383259 ## 198:     1     2 1.103883 ## 199:     1     3 1.660835 ## 200:     1     5 2.183518 est_ipw <- ipw_shift(   W = dat_obs$W, A = dat_obs$A, Y = dat_obs$Y,   delta = 2,   cv_folds = 5L,   n_bins = 4L,   bin_type = \"equal_range\",   selector_type = \"all\",   lambda_seq = exp(seq(-1, -10, length = 500L)),   # arguments passed to hal9001::fit_hal()   max_degree = 1,   reduce_basis = 1 / sqrt(n_obs) ) confint(est_ipw) ## # A tibble: 6 × 8 ##   lwr_ci   psi upr_ci se_est type           l1_norm lambda_idx gn_nbins ##    <dbl> <dbl>  <dbl>  <dbl> <chr>            <dbl>      <dbl>    <int> ## 1  0.570 0.668  0.753 0.0469 gcv               10.3        254        4 ## 2  0.570 0.668  0.753 0.0469 dcar_tol          10.3        254        4 ## 3  0.561 0.657  0.741 0.0464 dcar_min          23.7        295        4 ## 4  0.564 0.658  0.740 0.0452 lepski_plateau    30.7        301        4 ## 5  0.561 0.657  0.741 0.0464 smooth_plateau    23.7        295        4 ## 6  0.561 0.657  0.741 0.0464 hybrid_plateau    23.7        295        4"},{"path":[]},{"path":"https://codex.nimahejazi.org/haldensify/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nima Hejazi. Author, maintainer, copyright holder. David Benkeser. Author. Mark van der Laan. Author, thesis advisor. Rachael Phillips. Contributor.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hejazi N, Benkeser D, van der Laan M (2025). haldensify: Highly adaptive lasso conditional density estimation. doi:10.5281/zenodo.3698329, R package version 0.2.8, https://github.com/nhejazi/haldensify. Hejazi N, van der Laan M, Benkeser D (2022). “haldensify: Highly adaptive lasso conditional density estimation R.” Journal Open Source Software. doi:10.21105/joss.04522, https://doi.org/10.21105/joss.04522. Hejazi N, Benkeser D, Díaz , van der Laan M (2022). “Efficient estimation modified treatment policy effects based generalized propensity score.” arXiv. https://arxiv.org/abs/2205.05777.","code":"@Manual{,   title = {{haldensify}: Highly adaptive lasso conditional density estimation},   author = {Nima S Hejazi and David Benkeser and Mark J {van der Laan}},   year = {2025},   note = {R package version 0.2.8},   doi = {10.5281/zenodo.3698329},   url = {https://github.com/nhejazi/haldensify}, } @Article{,   title = {{haldensify}: Highly adaptive lasso conditional density estimation in {R}},   author = {Nima S Hejazi and Mark J {van der Laan} and David Benkeser},   year = {2022},   journal = {Journal of Open Source Software},   publisher = {The Open Journal},   doi = {10.21105/joss.04522},   url = {https://doi.org/10.21105/joss.04522}, } @Article{,   title = {Efficient estimation of modified treatment policy effects based on the generalized propensity score},   author = {Nima S Hejazi and David Benkeser and Iván Díaz and Mark J {van der Laan}},   year = {2022},   journal = {arXiv},   url = {https://arxiv.org/abs/2205.05777}, }"},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"rhaldensify","dir":"","previous_headings":"","what":"Highly Adaptive Lasso Conditional Density Estimation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"Highly Adaptive Lasso Conditional Density Estimation Authors: Nima Hejazi, David Benkeser, Mark van der Laan","code":""},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"whats-haldensify","dir":"","previous_headings":"","what":"What’s haldensify?","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"haldensify R package designed provide facilities nonparametric conditional density estimation based flexible procedure proposed initially Dı́az van der Laan (2011). core implemented methodology involves recovering conditional density estimates performing pooled hazards regressions assess conditional hazard observed value falls given bin (conditional) support variable interest. conditional density estimates useful, example, causal inference problems generalized propensity score (continuous-valued exposures) must estimated (Dı́az van der Laan 2012, 2018; Dı́az Hejazi 2020). haldensify implements conditional density estimation strategy use highly adaptive lasso (HAL) (Benkeser van der Laan 2016; van der Laan 2017; van der Laan Benkeser 2018; Coyle et al. 2022; Hejazi, Coyle, van der Laan 2020). Since generalized propensity score key ingredient inverse probability weighting (IPW) methods, haldensify builds advances Ertefaie, Hejazi, van der Laan (2022) Hejazi et al. (2022) provide non-parametric IPW estimators causal effects continuous treatments, achieve semi-parametric efficiency bound undersmoothing along family HAL conditional density estimators.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"standard use, recommend installing package CRAN via contribute, install development version haldensify GitHub:","code":"install.packages(\"haldensify\") remotes::install_github(\"nhejazi/haldensify\")"},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"simple example illustrates haldensify may used train highly adaptive lasso model obtain conditional density estimates: can also visualize empirical risk (respect density loss) terms solution path lasso regularization parameter:  Finally, can obtain conditional density estimates trained model training (new) data: details, check package vignette corresponding pkgdown site.","code":"library(haldensify) #> haldensify v0.2.8: Highly Adaptive Lasso Conditional Density Estimation set.seed(76924)  # simulate data: W ~ U[-4, 4] and A|W ~ N(mu = W, sd = 0.25) n_train <- 100 w <- runif(n_train, -4, 4) a <- rnorm(n_train, w, 0.25)  # HAL-based density estimate of A|W haldensify_fit <- haldensify(   A = a, W = w,   n_bins = 10, grid_type = \"equal_range\",   lambda_seq = exp(seq(-1, -10, length = 100)),   # arguments passed to hal9001::fit_hal()   max_degree = 3,   reduce_basis = 1 / sqrt(n_train) ) haldensify_fit #> HAL Conditional Density Estimation #> Number of bins over support of A: 10 #> CV-selected lambda: 0.0016 #> Summary of fitted HAL: #>          coef                                    term #>         <num>                                  <char> #>  1:  5.989688                             (Intercept) #>  2: 10.498800                      [ I(bin_id >= 2) ] #>  3: -9.673620                      [ I(W >= -3.353) ] #>  4:  8.659440                      [ I(bin_id >= 6) ] #>  5: -8.272041 [ I(bin_id >= 2) ] * [ I(W >= -2.371) ] #>  6: -8.261273                      [ I(W >= -3.109) ] #>  7:  8.054827                      [ I(bin_id >= 7) ] #>  8:  8.013383                      [ I(bin_id >= 4) ] #>  9:  8.001995                      [ I(bin_id >= 5) ] #> 10: -7.649731                      [ I(W >= -2.157) ] plot(haldensify_fit) # use the built-in predict method to get predictions pred_haldensify <- predict(haldensify_fit, new_A = a, new_W = w) head(pred_haldensify) #> [1] 0.2818730 0.5513780 0.4449961 0.5329549 0.8722028 0.6150810"},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"encounter bugs specific feature requests, please file issue.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"Contributions welcome. Interested contributors consult contribution guidelines prior submitting pull request.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"using haldensify R package, please cite following:","code":"@article{hejazi2022efficient,       author = {Hejazi, Nima S and Benkeser, David and D{\\'\\i}az, Iv{\\'a}n         and {van der Laan}, Mark J},       title = {Efficient estimation of modified treatment policy effects         based on the generalized propensity score},       year = {2022},       journal = {},       publisher = {},       volume = {},       number = {},       pages = {},       doi = {},       url = {https://arxiv.org/abs/2205.05777}     }      @article{hejazi2022haldensify-joss,       author = {Hejazi, Nima S and {van der Laan}, Mark J and Benkeser,         David C},       title = {{haldensify}: Highly adaptive lasso conditional density         estimation in {R}},       year  = {2022},       doi = {10.21105/joss.04522},       url = {https://doi.org/10.21105/joss.04522},       journal = {Journal of Open Source Software},       publisher = {The Open Journal}     }      @software{hejazi2022haldensify-rpkg,       author = {Hejazi, Nima S and Benkeser, David C and {van der Laan},         Mark J},       title = {{haldensify}: Highly adaptive lasso conditional density         estimation},       year  = {2022},       howpublished = {\\url{https://github.com/nhejazi/haldensify}},       doi = {10.5281/zenodo.3698329},       url = {https://doi.org/10.5281/zenodo.3698329},       note = {{R} package version 0.2.5}     }"},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"related","dir":"","previous_headings":"","what":"Related","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"R/hal9001 – highly adaptive lasso estimator used internally constructed conditional density estimates.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"funding","dir":"","previous_headings":"","what":"Funding","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"development software supported part grants National Library Medicine (award number T32 LM012417), National Institute Allergy Infectious Diseases (award number R01 AI074345) National Institutes Health, National Science Foundation (award number DMS 2102840).","code":""},{"path":"https://codex.nimahejazi.org/haldensify/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Highly Adaptive Lasso Conditional Density Estimation","text":"© 2019-2025 Nima S. Hejazi contents repository distributed MIT license. See details:","code":"MIT License  Copyright (c) 2019-2025 Nima S. Hejazi  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."},{"path":[]},{"path":"https://codex.nimahejazi.org/haldensify/reference/confint.ipw_haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","title":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","text":"Confidence Intervals IPW Estimates Causal Effects Stochatic Shift Interventions","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/confint.ipw_haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","text":"","code":"# S3 method for class 'ipw_haldensify' confint(object, parm = seq_len(object$psi), level = 0.95, ...)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/confint.ipw_haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","text":"object object class ipw_haldensify, produced invoking function ipw_shift, confidence interval computed. parm numeric vector indicating indices object$est return confidence intervals. level numeric indicating nominal level confidence interval computed. ... arguments. currently used.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/confint.ipw_haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","text":"named numeric vector containing parameter estimate  ipw_haldensify object, alongside lower/upper Wald-style confidence  intervals specified coverage level.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/confint.ipw_haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","text":"Compute confidence intervals estimates produced  ipw_shift.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/confint.ipw_haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confidence Intervals for IPW Estimates of the Causal Effects of Stochatic Shift Interventions — confint.ipw_haldensify","text":"","code":"# simulate data n_obs <- 50 W1 <- rbinom(n_obs, 1, 0.6) W2 <- rbinom(n_obs, 1, 0.2) W3 <- rpois(n_obs, 3) A <- rpois(n_obs, 3 * W1 - W2 + 2 * W1 * W2 + 4) Y <- rbinom(n_obs, 1, plogis(A + W1 + W2 - W3 - W1 * W3))  # fit the IPW estimator est_ipw <- ipw_shift(   W = cbind(W1, W2, W3), A = A, Y = Y,   delta = 0.5, cv_folds = 3L,   n_bins = 5L, bin_type = \"equal_range\",   lambda_seq = exp(seq(-1, -10, length = 100L)),   # arguments passed to hal9001::fit_hal()   max_degree = 2,   smoothness_orders = 0,   reduce_basis = 1 / sqrt(n_obs) ) #> 2% of observations outside training support...predictions trimmed. confint(est_ipw) #> # A tibble: 2 × 8 #>   lwr_ci   psi upr_ci se_est type     l1_norm lambda_idx gn_nbins #>    <dbl> <dbl>  <dbl>  <dbl> <chr>      <dbl>      <dbl>    <int> #> 1  0.601  0.74  0.843 0.0627 dcar_tol    4.64         32        5 #> 2  0.601  0.74  0.843 0.0627 dcar_min    4.64         32        5"},{"path":"https://codex.nimahejazi.org/haldensify/reference/cv_haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"HAL Conditional Density Estimation in a Cross-validation Fold — cv_haldensify","title":"HAL Conditional Density Estimation in a Cross-validation Fold — cv_haldensify","text":"HAL Conditional Density Estimation Cross-validation Fold","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/cv_haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HAL Conditional Density Estimation in a Cross-validation Fold — cv_haldensify","text":"","code":"cv_haldensify(   fold,   long_data,   wts = rep(1, nrow(long_data)),   lambda_seq = exp(seq(-1, -13, length = 1000L)),   smoothness_orders = 0L,   ... )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/cv_haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HAL Conditional Density Estimation in a Cross-validation Fold — cv_haldensify","text":"fold Object specifying cross-validation folds generated call make_folds. long_data data.table data.frame object containing data long format, given Díaz , van der Laan MJ (2011). “Super learner based conditional density estimation application marginal structural models.” International Journal Biostatistics, 7(1), 1–20. doi:10.2202/1557-4679.1356 . , produced format_long_hazards. wts numeric vector observation-level weights, matching length number records present long format data. Default weight observations equally. lambda_seq numeric sequence values regularization parameter Lasso regression; passed fit_hal. smoothness_orders integer indicating smoothness HAL basis functions; passed fit_hal. default set zero, indicator basis functions. ... Additional (optional) arguments fit_hal may used control fitting HAL regression model. Possible choices include use_min, reduce_basis, return_lasso, return_x_basis, list exhaustive. Consult documentation fit_hal complete details.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/cv_haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"HAL Conditional Density Estimation in a Cross-validation Fold — cv_haldensify","text":"list, containing density predictions, observations IDs,  observation-level weights, cross-validation indices conditional  density estimation single fold overall data.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/cv_haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HAL Conditional Density Estimation in a Cross-validation Fold — cv_haldensify","text":"Estimates conditional density |W subset full  set observations based inputted structure cross-validation  folds. helper function intended used select optimal  value penalization parameter highly adaptive lasso estimates  conditional hazard (via cross_validate). ","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/dcar_selector.html","id":null,"dir":"Reference","previous_headings":"","what":"Targeted IPW Estimator Selector via Solving the Efficient Influence Function — dcar_selector","title":"Targeted IPW Estimator Selector via Solving the Efficient Influence Function — dcar_selector","text":"Targeted IPW Estimator Selector via Solving Efficient Influence Function","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/dcar_selector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Targeted IPW Estimator Selector via Solving the Efficient Influence Function — dcar_selector","text":"","code":"dcar_selector(   W,   A,   Y,   delta = 0,   gn_pred_natural,   gn_pred_shifted,   Qn_pred_natural,   Qn_pred_shifted )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/dcar_selector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Targeted IPW Estimator Selector via Solving the Efficient Influence Function — dcar_selector","text":"W matrix, data.frame, similar containing set baseline covariates. numeric vector corresponding exposure variable. parameter interest defined location shift quantity. Y numeric vector observed outcomes. delta numeric value indicating shift exposure used defining target parameter. defined respect scale exposure (). gn_pred_natural matrix conditional density estimates exposure mechanism g(|W) along grid regularization parameter, natural (.e., observed) values exposure. gn_pred_shifted matrix conditional density estimates exposure mechanism g(+delta|W) along grid regularization parameter, shifted (.e., counterfactual) values exposure. Qn_pred_natural numeric outcome mechanism estimate natural (.e., observed) values exposure. HAL regression used estimate, regularization term chosen cross-validation. Qn_pred_shifted numeric outcome mechanism estimate shifted (.e., counterfactual) values exposure. HAL regression used estimate, regularization term chosen cross-validation.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/est_dcar.html","id":null,"dir":"Reference","previous_headings":"","what":"DCAR Projection of the Efficient Influence Function — est_dcar","title":"DCAR Projection of the Efficient Influence Function — est_dcar","text":"DCAR Projection Efficient Influence Function","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/est_dcar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DCAR Projection of the Efficient Influence Function — est_dcar","text":"","code":"est_dcar(   psi_ipw,   gn_pred_natural,   gn_pred_shifted,   Qn_pred_natural,   Qn_pred_shifted )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/est_dcar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DCAR Projection of the Efficient Influence Function — est_dcar","text":"psi_ipw numeric vector IPW point estimates corresponding conditional density estimates exposure mechanism provided arguments gn_pred_natural gn_pred_shifted. gn_pred_natural matrix conditional density estimates exposure mechanism g(|W) along grid regularization parameter, natural (.e., observed) values exposure. gn_pred_shifted matrix conditional density estimates exposure mechanism g(+delta|W) along grid regularization parameter, shifted (.e., counterfactual) values exposure. Qn_pred_natural numeric outcome mechanism estimate natural (.e., observed) values exposure. HAL regression used estimate, regularization term chosen cross-validation. Qn_pred_shifted numeric outcome mechanism estimate shifted (.e., counterfactual) values exposure. HAL regression used estimate, regularization term chosen cross-validation.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/fit_haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","title":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","text":"Fit Conditional Density Estimation Sequence HAL Models","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/fit_haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","text":"","code":"fit_haldensify(   A,   W,   wts = rep(1, length(A)),   grid_type = \"equal_range\",   n_bins = round(c(0.5, 1, 1.5, 2) * sqrt(length(A))),   cv_folds = 5L,   lambda_seq = exp(seq(-1, -13, length = 1000L)),   smoothness_orders = 0L,   ... )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/fit_haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","text":"numeric vector observed values. W data.frame, matrix, similar giving values baseline covariates (potential confounders) observed units. make conditioning set conditional density estimate. wts numeric vector observation-level weights. default weight observations equally. grid_type character indicating strategy used creating bins along observed support . bins equal range, use \"equal_range\"; consult documentation cut_interval information. ensure bin number observations, use \"equal_mass\"; consult documentation cut_number details. n_bins numeric value indicates number(s) bins support divided. grid_type, multiple values may specified, case cross-validation used choose optimal number bins. default sets candidate choices number bins based heuristics tested simulation. cv_folds numeric indicating number cross-validation folds used fitting sequence HAL conditional density models. lambda_seq numeric sequence values regularization parameter Lasso regression; passed fit_hal. smoothness_orders integer indicating smoothness HAL basis functions; passed fit_hal. default set zero, indicator basis functions. ... Additional (optional) arguments fit_hal may used control fitting HAL regression model. Possible choices include use_min, reduce_basis, return_lasso, return_x_basis, list exhaustive. Consult documentation fit_hal complete details.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/fit_haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","text":"list, containing density predictions sequence  fitted HAL models; index value L1 regularization parameter  minimizing density loss; sequence empirical risks  sequence fitted HAL models.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/fit_haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","text":"Estimation conditional density |W via cross-validated  highly adaptive lasso, used estimate conditional hazard failure  given bin support .","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/fit_haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Conditional Density Estimation over a Sequence of HAL Models — fit_haldensify","text":"","code":"# simulate data: W ~ U[-4, 4] and A|W ~ N(mu = W, sd = 0.5) set.seed(11249) n_train <- 50 w <- runif(n_train, -4, 4) a <- rnorm(n_train, w, 0.5) # fit cross-validated HAL-based density estimator of A|W haldensify_cvfit <- fit_haldensify(   A = a, W = w, n_bins = 10L, lambda_seq = exp(seq(-1, -10, length = 100)),   # the following arguments are passed to hal9001::fit_hal()   max_degree = 3, reduce_basis = 1 / sqrt(length(a)) )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/format_long_hazards.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Augmented Repeated Measures Data for Pooled Hazards Regression — format_long_hazards","title":"Generate Augmented Repeated Measures Data for Pooled Hazards Regression — format_long_hazards","text":"Generate Augmented Repeated Measures Data Pooled Hazards Regression","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/format_long_hazards.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Augmented Repeated Measures Data for Pooled Hazards Regression — format_long_hazards","text":"","code":"format_long_hazards(   A,   W,   wts = rep(1, length(A)),   grid_type = c(\"equal_range\", \"equal_mass\"),   n_bins = NULL,   breaks = NULL )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/format_long_hazards.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Augmented Repeated Measures Data for Pooled Hazards Regression — format_long_hazards","text":"numeric vector similar observed values intervention group observational units interest. W data.frame, matrix, similar giving values baseline covariates (potential confounders) observed units whose observed intervention values provided previous argument. wts numeric vector observation-level weights. default weight observations equally. grid_type character indicating strategy (strategies) used creating bins along observed support intervention . bins equal range, use \"equal_range\"; consult documentation cut_interval information. ensure bin number points, use \"equal_mass\"; consult documentation cut_number details. n_bins used grid_type set \"equal_range\" \"equal_mass\". numeric value indicates number(s) bins support divided. breaks numeric vector break points used dividing support . passed ... argument cut.default cut_interval cut_number.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/format_long_hazards.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Augmented Repeated Measures Data for Pooled Hazards Regression — format_long_hazards","text":"list containing break points used dividing  support discrete bins, length bin,  reformatted, \"repeated measures\" dataset. reformatted dataset  data.table repeated entries observations  bin falls, including indicator  bin observation falls , bin ID, observation ID, values  W observation, , possibly, observation-level weights.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/format_long_hazards.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Augmented Repeated Measures Data for Pooled Hazards Regression — format_long_hazards","text":"Generates augmented (long format, repeated measures) dataset  includes multiple records observation, single record  discretized bin including bin given observed  value falls. bins derived selecting break points  support . repeated measures dataset suitable estimating  hazard failing particular bin using highly adaptive  lasso () classification model.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/gcv_selector.html","id":null,"dir":"Reference","previous_headings":"","what":"IPW Estimator Selector via Global Cross-Validation — gcv_selector","title":"IPW Estimator Selector via Global Cross-Validation — gcv_selector","text":"IPW Estimator Selector via Global Cross-Validation","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/gcv_selector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IPW Estimator Selector via Global Cross-Validation — gcv_selector","text":"","code":"gcv_selector(   W,   A,   Y,   delta = 0,   gn_pred_natural,   gn_pred_shifted,   Qn_pred_natural,   Qn_pred_shifted )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/gcv_selector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IPW Estimator Selector via Global Cross-Validation — gcv_selector","text":"W matrix, data.frame, similar containing set baseline covariates. numeric vector corresponding exposure variable. parameter interest defined location shift quantity. Y numeric vector observed outcomes. delta numeric value indicating shift exposure used defining target parameter. defined respect scale exposure (). gn_pred_natural matrix conditional density estimates exposure mechanism g(|W) along grid regularization parameter, natural (observed, actual) values exposure. gn_pred_shifted matrix conditional density estimates exposure mechanism g(+delta|W) along grid regularization parameter, shifted (counterfactual) values exposure. Qn_pred_natural numeric outcome mechanism estimate natural (.e., observed) values exposure. HAL regression used estimate, regularization term chosen cross-validation. Qn_pred_shifted numeric outcome mechanism estimate shifted (.e., counterfactual) values exposure. HAL regression used estimate, regularization term chosen cross-validation.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated HAL Conditional Density Estimation — haldensify","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"Cross-validated HAL Conditional Density Estimation","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"","code":"haldensify(   A,   W,   wts = rep(1, length(A)),   grid_type = \"equal_range\",   n_bins = round(c(0.5, 1, 1.5, 2) * sqrt(length(A))),   cv_folds = 5L,   lambda_seq = exp(seq(-1, -13, length = 1000L)),   smoothness_orders = 0L,   hal_basis_list = NULL,   ... )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"numeric vector observed values. W data.frame, matrix, similar giving values baseline covariates (potential confounders) observed units. make conditioning set density estimate. estimation marginal density, specify constant numeric vector NULL. wts numeric vector observation-level weights. default weight observations equally. grid_type character indicating strategy used creating bins along observed support . bins equal range, use \"equal_range\"; consult documentation cut_interval information. ensure bin number observations, use \"equal_mass\"; consult documentation cut_number details. default \"equal_range\" since found provide better performance simulation experiments; however, types may specified (.e., c(\"equal_range\", \"equal_mass\")) together, case cross-validation used select optimal binning strategy. n_bins numeric value indicates number(s) bins support divided. grid_type, multiple values may specified, case cross-validation used choose optimal number bins. default sets candidate choices number bins based heuristics tested simulation. cv_folds numeric indicating number cross-validation folds used fitting sequence HAL conditional density models. lambda_seq numeric sequence values regularization parameter Lasso regression; passed fit_hal via argument lambda. smoothness_orders integer indicating smoothness HAL basis functions; passed fit_hal. default set zero, indicator basis functions. hal_basis_list list consisting preconstructed set HAL basis functions, produced fit_hal. default NULL results creating set basis functions. specified, passed directly HAL model fitted upon augmented (repeated measures) data structure, resulting much lowered computational cost. useful, example, fitting HAL conditional density estimates external cross-validation bootstrap samples. ... Additional (optional) arguments fit_hal may used control fitting HAL regression model. Possible choices include use_min, reduce_basis, return_lasso, return_x_basis, list exhaustive. Consult documentation fit_hal complete details.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"Object class haldensify, containing fitted  hal9001 object; vector break points used binning  support W; sizes bins used fit; tuning  parameters selected cross-validation; full sequence (lambda)  HAL models CV-selected number bins binning strategy;  range .","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"Estimation conditional density |W using highly  adaptive lasso estimate conditional hazard failure given  bin support . Cross-validation used select optimal  value penalization parameters, based minimization weighted  log-likelihood loss density.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"Parallel evaluation cross-validation procedure select tuning  parameters density estimation may invoked via framework exposed  future ecosystem. Specifically, set plan  future_mapply used internally.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validated HAL Conditional Density Estimation — haldensify","text":"","code":"# simulate data: W ~ U[-4, 4] and A|W ~ N(mu = W, sd = 0.5) set.seed(11249) n_train <- 50 w <- runif(n_train, -4, 4) a <- rnorm(n_train, w, 0.5) # learn relationship A|W using HAL-based density estimation procedure haldensify_fit <- haldensify(   A = a, W = w, n_bins = 10L, lambda_seq = exp(seq(-1, -10, length = 100)),   # the following arguments are passed to hal9001::fit_hal()   max_degree = 3, reduce_basis = 1 / sqrt(length(a)) )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/ipw_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"IPW Estimator of the Causal Effects of Additive Modified Treatment Policies — ipw_shift","title":"IPW Estimator of the Causal Effects of Additive Modified Treatment Policies — ipw_shift","text":"IPW Estimator Causal Effects Additive Modified Treatment Policies","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/ipw_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IPW Estimator of the Causal Effects of Additive Modified Treatment Policies — ipw_shift","text":"","code":"ipw_shift(   W,   A,   Y,   delta = 0,   n_bins = make_bins(A, \"hist\"),   cv_folds = 10L,   lambda_seq,   ...,   bin_type = c(\"equal_range\", \"equal_mass\"),   selector_type = c(\"dcar\", \"plateau\", \"gcv\", \"all\") )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/ipw_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IPW Estimator of the Causal Effects of Additive Modified Treatment Policies — ipw_shift","text":"W matrix, data.frame, similar containing set baseline covariates. numeric vector corresponding exposure variable. parameter interest defined location shift quantity. Y numeric vector observed outcomes. delta numeric value indicating shift exposure used defining target parameter. defined respect scale exposure (). n_bins numeric, scalar vector, indicating number bins support partitioned constructing conditional density estimates. cv_folds numeric giving number folds used cross-validation. Note form sample splitting used selection tuning parameters empirical risk minimization, estimation nuisance parameters (.e., relax regularity conditions). lambda_seq numeric sequence regularization parameter (L1 norm HAL coefficients) used fitting HAL models. ... Additional arguments model fitting passed directly haldensify. bin_type character indicating strategy used creating bins along observed support . bins equal range, use \"equal_range\"; ensure bin number observations, use instead \"equal_mass\". information, see documentation grid_type haldensify. selector_type character indicating selection strategy identifying efficent IPW estimator. choices include \"gcv\" global cross-validation, \"dcar\" solving EIF equation, \"plateau\" agnostic approaches (1) balancing changes IPW estimate standard error (adapting Lepski's method) (2) plateau detector inflection points IPW estimator's trajectory. option \"\" runs three selection strategies sharing redundant computation .","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/ipw_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IPW Estimator of the Causal Effects of Additive Modified Treatment Policies — ipw_shift","text":"","code":"# simulate data set.seed(11249) n_obs <- 50 W1 <- rbinom(n_obs, 1, 0.6) W2 <- rbinom(n_obs, 1, 0.2) W3 <- rpois(n_obs, 3) A <- rpois(n_obs, 3 * W1 - W2 + 2 * W1 * W2 + 4) Y <- rbinom(n_obs, 1, plogis(A + W1 + W2 - W3 - W1 * W3))  # fit the IPW estimator est_ipw <- ipw_shift(   W = cbind(W1, W2, W3), A = A, Y = Y,   delta = 0.5, cv_folds = 3L,   n_bins = 4L, bin_type = \"equal_range\",   lambda_seq = exp(seq(-1, -10, length = 100L)),   # arguments passed to hal9001::fit_hal()   max_degree = 1L,   smoothness_orders = 0,   reduce_basis = 1 / sqrt(n_obs) ) #> 8% of observations outside training support...predictions trimmed."},{"path":"https://codex.nimahejazi.org/haldensify/reference/make_bins.html","id":null,"dir":"Reference","previous_headings":"","what":"Histogram Binning Procedures for Pooled Hazards Regression — make_bins","title":"Histogram Binning Procedures for Pooled Hazards Regression — make_bins","text":"Histogram Binning Procedures Pooled Hazards Regression","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/make_bins.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Histogram Binning Procedures for Pooled Hazards Regression — make_bins","text":"","code":"make_bins(grid_var, grid_type = c(\"hist\", \"scaled\"), max_bins = 30L)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/make_bins.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Histogram Binning Procedures for Pooled Hazards Regression — make_bins","text":"grid_var numeric vector histogram-based binning performed. grid_type character indicating choice binning rule, \"hist\" corresponding use several rules proposed optimal histogram construction \"scaled\" corresponding use various pre-set multiples square root sample size. max_bins numeric indicating maximum number bins allowed grid building histogram based discretization.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/map_hazard_to_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Map Predicted Hazard to Predicted Density for a Single Observation — map_hazard_to_density","title":"Map Predicted Hazard to Predicted Density for a Single Observation — map_hazard_to_density","text":"Map Predicted Hazard Predicted Density Single Observation","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/map_hazard_to_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map Predicted Hazard to Predicted Density for a Single Observation — map_hazard_to_density","text":"","code":"map_hazard_to_density(hazard_pred_single_obs)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/map_hazard_to_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map Predicted Hazard to Predicted Density for a Single Observation — map_hazard_to_density","text":"hazard_pred_single_obs numeric vector predicted hazard failure given bin (given partitioning support) single observational unit based long format data structure (format_long_hazards). probability given value falls corresponding bin, given yet failed (fallen preceding bin), per Díaz , van der Laan MJ (2011). “Super learner based conditional density estimation application marginal structural models.” International Journal Biostatistics, 7(1), 1–20. doi:10.2202/1557-4679.1356 . .","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/map_hazard_to_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map Predicted Hazard to Predicted Density for a Single Observation — map_hazard_to_density","text":"matrix composed single row number columns  specified grid penalization parameters used fitting  highly adaptive lasso. predicted conditional density  given observation, re-mapped hazard scale.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/map_hazard_to_density.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map Predicted Hazard to Predicted Density for a Single Observation — map_hazard_to_density","text":"single observation, map predicted hazard failure ( occurrence particular bin, given partitioning support)  density.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/plateau_selector.html","id":null,"dir":"Reference","previous_headings":"","what":"Agnostic IPW Estimator Selector via Lepski's and Variance-Blind Methods — plateau_selector","title":"Agnostic IPW Estimator Selector via Lepski's and Variance-Blind Methods — plateau_selector","text":"Agnostic IPW Estimator Selector via Lepski's Variance-Blind Methods","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/plateau_selector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agnostic IPW Estimator Selector via Lepski's and Variance-Blind Methods — plateau_selector","text":"","code":"plateau_selector(   W,   A,   Y,   delta = 0,   gn_pred_natural,   gn_pred_shifted,   gn_fit_haldensify,   Qn_pred_natural,   Qn_pred_shifted,   cv_folds = 10L,   ci_level = 0.95,   l1norm_mult = 10L )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/plateau_selector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agnostic IPW Estimator Selector via Lepski's and Variance-Blind Methods — plateau_selector","text":"W matrix, data.frame, similar containing set baseline covariates. numeric vector corresponding exposure variable. parameter interest defined location shift quantity. Y numeric vector observed outcomes. delta numeric value indicating shift exposure used defining target parameter. defined respect scale exposure (). gn_pred_natural matrix conditional density estimates exposure mechanism g(|W) along grid regularization parameter, natural (observed, actual) values exposure. gn_pred_shifted matrix conditional density estimates exposure mechanism g(+delta|W) along grid regularization parameter, shifted (counterfactual) values exposure. gn_fit_haldensify object class haldensify fitted conditional density model natural exposure mechanism. fit object returned haldensify[haldensify] part call ipw_shift. Qn_pred_natural numeric outcome mechanism estimate natural (.e., observed) values exposure. HAL regression used estimate, regularization term chosen cross-validation. Qn_pred_shifted numeric outcome mechanism estimate shifted (.e., counterfactual) values exposure. HAL regression used estimate, regularization term chosen cross-validation. cv_folds numeric giving number folds used cross-validation. Note form sample splitting used selection tuning parameters empirical risk minimization, estimation nuisance parameters (.e., relax regularity conditions). ci_level numeric indicating confidence level used determining cutoff used Lepski-type selector. exposed sake accommodating experimentation. l1norm_mult numeric indicating multipler used plateau-based selector reducing candidate set L1 norms relative choice made cross-validation selector.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/plot.haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for HAL Conditional Density Estimates — plot.haldensify","title":"Plot Method for HAL Conditional Density Estimates — plot.haldensify","text":"Plot Method HAL Conditional Density Estimates","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/plot.haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for HAL Conditional Density Estimates — plot.haldensify","text":"","code":"# S3 method for class 'haldensify' plot(x, ..., type = c(\"risk\", \"density\"))"},{"path":"https://codex.nimahejazi.org/haldensify/reference/plot.haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for HAL Conditional Density Estimates — plot.haldensify","text":"x Object class haldensify, containing conditional density estimates, produced haldensify. ... Additional arguments passed plot, currently ignored. type character indicating type plot produced. Options include visualizing empirical risks conditional density estimators across grid values regularization parameter plot estimated conditional density (based estimator selected cross-validation). latter yet implemented.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/plot.haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for HAL Conditional Density Estimates — plot.haldensify","text":"Object class ggplot containing plot desired  type.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/plot.haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for HAL Conditional Density Estimates — plot.haldensify","text":"","code":"# simulate data: W ~ U[-4, 4] and A|W ~ N(mu = W, sd = 0.5) n_train <- 50 w <- runif(n_train, -4, 4) a <- rnorm(n_train, w, 0.5) # learn relationship A|W using HAL-based density estimation procedure haldensify_fit <- haldensify(   A = a, W = w, n_bins = 3,   lambda_seq = exp(seq(-1, -10, length = 50)),   # the following arguments are passed to hal9001::fit_hal()   max_degree = 2L, smoothness_orders = 0L, reduce_basis = 0.1 ) plot(haldensify_fit)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/predict.haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","title":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","text":"Prediction Method HAL Conditional Density Estimation","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/predict.haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","text":"","code":"# S3 method for class 'haldensify' predict(   object,   ...,   new_A,   new_W,   trim = TRUE,   trim_min = NULL,   lambda_select = c(\"cv\", \"undersmooth\", \"all\") )"},{"path":"https://codex.nimahejazi.org/haldensify/reference/predict.haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","text":"object object class haldensify, containing results fitting highly adaptive lasso conditional density estimation, produced call haldensify. ... Additional arguments passed predict necessary. new_A numeric vector similar observed values conditional density estimate generated. new_W data.frame, matrix, similar giving values baseline covariates (potential confounders) conditioning set observed values . trim logical indicating whether estimates conditional density value indicated trim_min truncated. default value TRUE enforces truncation values cutoff specified trim_min similarly truncates predictions new_A falling outside training support. trim_min numeric indicating minimum allowed value resultant density predictions. predicted density values tolerance threshold set indicated minimum. default use scaled inverse square root sample size prediction set, .e., 5/sqrt(n)/log(n) (another notable choice 1/sqrt(n)). observations prediction set values new_A outside support training set (.e., provided argument haldensify), predictions similarly truncated. lambda_select character indicating whether return predicted density value regularization parameter chosen global cross-validation selector whether return undersmoothed sequence (starts cross-validation selector's choice also includes values sequence less restrictive). default \"cv\" global cross-validation selector. Setting choice \"undersmooth\" returns matrix predicted densities, column corresponding value regularization parameter less equal choice made global cross-validation selector. \"\" set, predictions returned full sequence regularization parameter HAL model object fitted.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/predict.haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","text":"numeric vector predicted conditional density values  fitted haldensify object.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/predict.haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","text":"Method computing extracting predictions conditional  density estimates based highly adaptive lasso estimator, returned  S3 object class haldensify haldensify.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/predict.haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction Method for HAL Conditional Density Estimation — predict.haldensify","text":"","code":"# simulate data: W ~ U[-4, 4] and A|W ~ N(mu = W, sd = 0.5) n_train <- 50 w <- runif(n_train, -4, 4) a <- rnorm(n_train, w, 0.5) # HAL-based density estimator of A|W haldensify_fit <- haldensify(   A = a, W = w, n_bins = 10L, lambda_seq = exp(seq(-1, -10, length = 100)),   # the following arguments are passed to hal9001::fit_hal()   max_degree = 2, smoothness_orders = 0L, reduce_basis = 1 / sqrt(length(a)) ) # predictions to recover conditional density of A|W new_a <- seq(-4, 4, by = 0.1) new_w <- rep(0, length(new_a)) pred_dens <- predict(haldensify_fit, new_A = new_a, new_W = new_w)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","title":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","text":"Print: Highly Adaptive Lasso Conditional Density Estimates","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","text":"","code":"# S3 method for class 'haldensify' print(x, ...)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","text":"x object class haldensify. ... options (currently used).","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","text":"None. Called side effect printing informative summary  slots objects class haldensify.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","text":"print method objects class haldensify","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print: Highly Adaptive Lasso Conditional Density Estimates — print.haldensify","text":"","code":"# simulate data: W ~ U[-4, 4] and A|W ~ N(mu = W, sd = 0.5) set.seed(11249) n_train <- 50 w <- runif(n_train, -4, 4) a <- rnorm(n_train, w, 0.5)  # learn relationship A|W using HAL-based density estimation procedure haldensify_fit <- haldensify(   A = a, W = w, n_bins = c(3, 5),   lambda_seq = exp(seq(-1, -15, length = 50L)),   max_degree = 2, smoothness_orders = 0, reduce_basis = 0.1 ) print(haldensify_fit) #> HAL Conditional Density Estimation #> Number of bins over support of A: 5 #> CV-selected lambda: 0.0038 #> Summary of fitted HAL: #>          coef               term #>         <num>             <char> #>  1:  13.66335        (Intercept) #>  2: -18.73701 [ I(W >= -2.086) ] #>  3: -15.56878 [ I(W >= -1.105) ] #>  4:  15.39282 [ I(W >= -1.612) ] #>  5:  15.17157 [ I(bin_id >= 2) ] #>  6:  13.70079 [ I(bin_id >= 3) ] #>  7: -13.35268  [ I(W >= 1.006) ] #>  8:  12.79074 [ I(bin_id >= 4) ] #>  9: -11.35484  [ I(W >= 1.884) ] #> 10:  11.30173  [ I(W >= 1.487) ]"},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.ipw_haldensify.html","id":null,"dir":"Reference","previous_headings":"","what":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","title":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","text":"Print: IPW Estimates Causal Effects Stochatic Shift Interventions","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.ipw_haldensify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","text":"","code":"# S3 method for class 'ipw_haldensify' print(x, ..., ci_level = 0.95)"},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.ipw_haldensify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","text":"x object class ipw_haldensify. ... options (currently used). ci_level numeric indicating level confidence interval computed.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.ipw_haldensify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","text":"None. Called side effect printing informative summary  slots objects class ipw_haldensify.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.ipw_haldensify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","text":"print method objects class ipw_haldensify","code":""},{"path":"https://codex.nimahejazi.org/haldensify/reference/print.ipw_haldensify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print: IPW Estimates of the Causal Effects of Stochatic Shift Interventions — print.ipw_haldensify","text":"","code":"# simulate data set.seed(11249) n_obs <- 50 W1 <- rbinom(n_obs, 1, 0.6) W2 <- rbinom(n_obs, 1, 0.2) A <- rnorm(n_obs, (2 * W1 - W2 - W1 * W2), 2) Y <- rbinom(n_obs, 1, plogis(3 * A + W1 + W2 - W1 * W2))  # fit the IPW estimator est_ipw_shift <- ipw_shift(   W = cbind(W1, W2), A = A, Y = Y,   delta = 0.5, n_bins = 3L, cv_folds = 3L,   lambda_seq = exp(seq(-1, -10, length = 100L)),   # arguments passed to hal9001::fit_hal()   max_degree = 1,   # ...continue arguments for IPW   selector_type = \"gcv\" ) #> 2% of observations outside training support...predictions trimmed. #> Warning: one multinomial or binomial class has fewer than 8  observations; dangerous ground print(est_ipw_shift) #> Counterfactual Mean of Shifted Treatment #> Intervention: Treatment + 0.5 #> IPW Estimator Criterion: Global CV #> Estimate: 0.7018 #> Std. Error: 0.0749 #> 95% CI: [0.5386, 0.8259] #> EIF Mean: -0.0497"},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-028","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.8","title":"haldensify 0.2.8","text":"CRAN release: 2025-09-02 September 2025: Fix documentation error format_long_hazards per CRAN warning package references “use package anchors, .e., use \\link[PKG]{FOO}” (see https://github.com/nhejazi/haldensify/issues/44). Export predict method haldensify objects rather registering solely S3 method generic, allowing packages easily reference export (see https://github.com/nhejazi/haldensify/issues/45). See https://github.com/r-lib/roxygen2/issues/1322 suggestion export method predict.xy manually via Roxygen2 export tag.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-027","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.7","title":"haldensify 0.2.7","text":"September 2024: Continue fixing issues incorrectly passing n_folds glmnet, argument nfolds (see https://github.com/nhejazi/haldensify/issues/41).","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-026","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.6","title":"haldensify 0.2.6","text":"February 2024: Updated versions hal9001 origami DESCRIPTION match latest CRAN releases, resolving bugs related Matrix v1.6-2 reported https://github.com/tlverse/hal9001/issues/109. Catch fix incorrect internal references (n_folds) glmnet formal argument nfolds, previously dropped hal9001.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-025","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.5","title":"haldensify 0.2.5","text":"May 2021: Updated nonparametric IPW estimation code match methods described https://arxiv.org/abs/2205.05777. Updated tests, references, pkgdown site preparation JOSS paper.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-022","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.2","title":"haldensify 0.2.2","text":"CRAN release: 2022-01-27 October 2021: Removed LazyData field DESCRIPTION since data directory present. Removed reference glmnet documentation avoid adding package dependencies.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-021","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.1","title":"haldensify 0.2.1","text":"CRAN release: 2021-10-08 October 2021: Reduced time-intensive nature unit tests per CRAN policies. Added smoothness_orders named argument haldensify, fit_haldensify, cv_haldensify, default zero. previously passed hal9001::fit_hal via ... arguments. Submission accepted posted CRAN.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-020","dir":"Changelog","previous_headings":"","what":"haldensify 0.2.0","title":"haldensify 0.2.0","text":"September 2021: Refinements internal calls hal9001::fit_hal() keeping updates package, compatibility v0.4.0 CRAN release. smoothness_orders argument hal9001::fit_hal() previously set ... argument haldensify; however, now made named argument haldensify internal cv_haldensify fit_haldensify functions. default set zero, indicator basis functions, differs default hal9001::fit_hal() v0.4.0 release.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-015","dir":"Changelog","previous_headings":"","what":"haldensify 0.1.5","title":"haldensify 0.1.5","text":"April 2021: Changes internal calls hal9001::fit_hal() order correctly use pared-interface introduced v0.4.0, contributed @rachaelvp. default grid bins used discretization variable altered multiples sqrt(length()).","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-010","dir":"Changelog","previous_headings":"","what":"haldensify 0.1.0","title":"haldensify 0.1.0","text":"April 2021: Updates haldensify arguments (removal hal_max_degree named argument) simplify better match use fit_hal hal9001 v0.3.0+. overhaul also included addition ... arguments, now passed haldensify fit_haldensify cv_haldensify, allowing internal calls hal9001::fit_hal() specify arguments passed fitting HAL models. Changes default values argument n_bins, now setting (much) larger values based sample size. accordance evidence simulation experiments indicating higher values n_bins lead significantly improved density estimates. Addition argument trim trim_dens predict.haldensify support use truncation transparently. default set predictions values new_A outside training support zero, changed avoid trimming , choice made trim predictions, set value 1/sqrt(length(new_A)). Addition new method print.haldensify user-friendly display prediction procedure’s output, including selected number bins, CV-selected choice regularization parameter, summary fitted HAL model.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-009","dir":"Changelog","previous_headings":"","what":"haldensify 0.0.9","title":"haldensify 0.0.9","text":"February 2021: Addition method plot.haldensify simplify visualizing empirical risks sequence HAL-based conditional density estimators across grid regularization parameter, necessary changes vignette. Preparation add option visualize conditional density estimates (estimator selected cross-validation) via type argument plot.haldensify method. yet implemented. Simplification unit tests remove unnecessary reliance dplyr. Limit re-fitting HAL model (CV-selection tuning parameters) haldensify() full-data fit explicitly passing n_folds = 1. Avoid cross-validation procedure conditionally arguments n_bin grid_type fixed; add related assertion check predict() haldensify() skips cross-validation (since lambda selection skipped). Change long-format repeated measures data passed around haldensify() predict() clarify variable passing. Correct predict() method truncate small conditional density estimates minimum value [1 / sqrt(n)], based prediction set sample size.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-008","dir":"Changelog","previous_headings":"","what":"haldensify 0.0.8","title":"haldensify 0.0.8","text":"January 2021: Addition argument hal_basis_list haldensify(), allowing HAL basis produced fit_hal() passed HAL regression used density estimation. facilitates reduced computational overhead requiring external cross-validation nuisance functions (e.g., CV-TMLE) well working bootstrap samples. Addition argument hal_max_degree haldensify(), allowing control highest degree interactions considered HAL model density estimation. Like , can reduce computational overhead. Fix minor bug haldensify() passing cv_folds n_folds argument fit_hal() fitting HAL regression density estimation. Previously, cv_folds used constructing cross-validation (CV) folds choosing tuning parameters, subsequent HAL regression fiex use default number folds specified fit_hal() choose regularization parameter HAL regression density estimation. Now, CV choose density estimation tuning parameters CV choose lasso tuning parameter use number folds. Addition argument ... haldensify() arbitrary arguments can passed fit_hal() density estimation, already specified arguments haldensify() constructor. Remove unnecessary argument use_future, specifying parallel evaluation note instead. Add option \"\" lambda_select argument predict() method, allowing predictions full (non-truncated) sequence lambdas fitted returned. Change truncation option predict() method 1/n instead zero.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-007","dir":"Changelog","previous_headings":"","what":"haldensify 0.0.7","title":"haldensify 0.0.7","text":"January 2021: Adds support facilitate convenient marginal density estimation creating automatically constant vector W = NULL set haldensify(). hal9001 dependency upgraded v0.2.8 package, introduced breaking changes names slots fitted model objects. sequence HAL models re-fit identification regularization parameter selected cross-validation padded aggressive choices parameter ameliorate convergence issues model fitting. Re-fitting HAL model cross-validated choices number bins, binning procedure, regularization sequence altered reuse regularization sequence provided input rather subsetting sequence start cross-validation selector’s choice parameter. Though convenient undersmoothing haldensify estimates, subsetting proved problematic convergence glmnet(). predict() method’s cv_select argument replaced order better facilitate undersmoothing. new argument lambda_select defaults cross-validation selector now easily allows access sequence undersmoothed density estimates (less restrictive regularization values). grid_type_tune_opt now grid_type_cvselect, n_bins_tune_opt now n_bins_cvselect, cv_hal_fits_tune_opt now cv_tuning_results.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-006","dir":"Changelog","previous_headings":"","what":"haldensify 0.0.6","title":"haldensify 0.0.6","text":"CRAN release: 2020-09-16 December 2020: Use plan(transparent) changed plan(sequential) based ongoing development future package ecosystem. June 2020: short software paper inclusion JOSS added. May 2020: core cross-validation routine haldensify fitting HAL models slightly abstracted moved new function fit_haldensify. haldensify() wrapper function serves cross-validate choices histogram binning strategy number bins. defaults haldensify() changed based results simulation experiments. unnecessary argument seed_int haldensify() removed. Fixes bug introduced returning predicted hazards vector instead matrix. argument cv_select, defaulting TRUE, added predict method, make undersmoothing accessible. simple vignette added.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-005","dir":"Changelog","previous_headings":"","what":"haldensify 0.0.5","title":"haldensify 0.0.5","text":"CRAN release: 2020-03-14 First CRAN release. Documentation updates.","code":""},{"path":"https://codex.nimahejazi.org/haldensify/news/index.html","id":"haldensify-003","dir":"Changelog","previous_headings":"","what":"haldensify 0.0.3","title":"haldensify 0.0.3","text":"First stable version package.","code":""}]
