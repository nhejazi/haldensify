<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Highly Adaptive Lasso Conditional Density Estimation • haldensify</title>
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Highly Adaptive Lasso Conditional Density Estimation">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">haldensify</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.8</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/intro_haldensify.html">Highly Adaptive Lasso Conditional Density Estimation</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/nhejazi/haldensify/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Highly Adaptive Lasso Conditional Density Estimation</h1>
                        <h4 data-toc-skip class="author">
<a href="https://nimahejazi.org" class="external-link">Nima Hejazi</a> and <a href="https://sph.emory.edu/profile/faculty/david-benkeser" class="external-link">David
Benkeser</a>
</h4>
            
            <h4 data-toc-skip class="date">2025-09-06</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/nhejazi/haldensify/blob/HEAD/vignettes/intro_haldensify.Rmd" class="external-link"><code>vignettes/intro_haldensify.Rmd</code></a></small>
      <div class="d-none name"><code>intro_haldensify.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="background-and-motivation">Background and motivation<a class="anchor" aria-label="anchor" href="#background-and-motivation"></a>
</h2>
<p>In causal inference problems, both classical estimators (e.g.,
inverse probability weighting) and doubly robust estimators (e.g.,
one-step estimation, targeted minimum loss estimation) require
estimation of the propensity score, a nuisance parameter corresponding
to the treatment mechanism. While treatments of interest may often be
continuous-valued, most approaches opt to discretize the treatment so as
to estimate effects based on binary (or categorical) treatment. Such
simplifications are often motivated by convenience rather than science –
to avoid estimation of the <em>generalized propensity score</em> <span class="citation">(Hirano and Imbens 2004; Imai and Van Dyk 2004)</span>,
the covariate-conditional treatment density. The <code>haldensify</code>
package introduces a flexible approach for estimating such conditional
density functions, using the highly adaptive lasso (HAL), a
nonparametric estimator that has been shown to exhibit desirable
rate-convergence properties.</p>
<p>Consider data generated by typical cohort sampling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>W</mi><mo>,</mo><mi>A</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O = (W, A, Y)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
is a vector of baseline covariates,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is a continuous (or ordinal) treatment, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is an outcome of interest. Estimation of the generalized propensity
score
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mn>0</mn><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{0,A}</annotation></semantics></math>
corresponds to estimating the conditional density of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">W =
w</annotation></semantics></math>. A simple strategy for estimating this
nuisance function is to assume a parametric working model and use
parametric regression to generate suitable density estimates. For
example, one could operate under the working assumption that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
follows a Gaussian distribution with homoscedastic variance and mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msub><mi>β</mi><mi>j</mi></msub><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sum_{j=1}^p \beta_j \phi_j(W)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mo>:</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi = (\phi_j : j)</annotation></semantics></math>
are user-selected basis functions and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>β</mi><mi>j</mi></msub><mo>:</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\beta = (\beta_j : j)</annotation></semantics></math>
are unknown regression parameters. In this case, a density estimate
would be generated by fitting a linear regression of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(W)</annotation></semantics></math>
to estimate the conditional mean of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>,
paired with maximum likelihood estimation of the variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
Then, the estimated conditional density would be given by the density of
a Gaussian distribution evaluated at these estimates. Unfortunately,
most such approaches do not allow for flexible modeling of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mn>0</mn><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{0,A}</annotation></semantics></math>.
This motivated our development of a novel and flexible procedure for
constructing conditional density estimators
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∣</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g_{n,A}(a \mid w)</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">W = w</annotation></semantics></math>
(possibly subject to observation-level weights).</p>
</div>
<div class="section level2">
<h2 id="conditional-density-estimation-by-pooled-hazards-regression">Conditional density estimation by pooled hazards regression<a class="anchor" aria-label="anchor" href="#conditional-density-estimation-by-pooled-hazards-regression"></a>
</h2>
<p>As consistent estimation of the generalized propensity score is an
integral part of constructing estimators of the causal effects of
continuous treatments, our conditional density estimator, built around
the HAL regression function, may be quite useful in flexibly
constructing such estimates. We note that proposals for the data
adaptive estimation of such quantities are sparse in the literature
(e.g., <span class="citation">Zhu, Coffman, and Ghosh (2015)</span>).
Notably, <span class="citation">Dı́az and van der Laan (2011)</span> gave
a proposal for constructing a semiparametric estimator of such a target
quantity based on exploiting the relationship between the hazard and
density functions. Our proposal builds upon theirs in several key
ways:</p>
<ol style="list-style-type: decimal">
<li>we adjust their algorithm so as to incorporate sample-level weights,
necessary for making use of sample-level weights (e.g., inverse
probability of censoring weighting); and</li>
<li>we replace their use of an arbitrary classification model with the
HAL regression function.</li>
</ol>
<p>While our first modification is general and may be applied to the
estimation strategy of <span class="citation">Dı́az and van der Laan
(2011)</span>, our latter contribution requires adjusting the
penalization aspect of HAL regression so as to respect the use of a loss
function appropriate for density estimation on the hazard scale.</p>
<p>To build an estimator of a conditional density, <span class="citation">Dı́az and van der Laan (2011)</span> considered
discretizing the observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>
based on a number of bins
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
and a binning procedure (e.g., including the same number of points in
each bin or forcing bins to be of the same length). We note that the
choice of the tuning parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
corresponds roughly to the choice of bandwidth in classical kernel
density estimation; this will be made clear upon further examination of
the proposed algorithm. The data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>A</mi><mo>,</mo><mi>W</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{A, W\}</annotation></semantics></math>
are reformatted such that the hazard of an observed value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>
falling in a given bin may be evaluated via standard classification
techniques. In fact, this proposal may be viewed as a re-formulation of
the classification problem into a corresponding set of hazard
regressions:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>ℙ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>ℙ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>A</mi><mo>≥</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>−</mo><mi>ℙ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>A</mi><mo>≥</mo><msub><mi>α</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
   \mathbb{P} (a \in [\alpha_{t-1}, \alpha_t) \mid W) =&amp; \mathbb{P} (a \in
   [\alpha_{t-1}, \alpha_t) \mid A \geq \alpha_{t-1}, W) \times  \\ &amp;
   \prod_{j = 1}^{t -1} \{1 - \mathbb{P} (a \in [\alpha_{j-1}, \alpha_j)
   \mid A \geq \alpha_{j-1}, W) \},
\end{align*}</annotation></semantics></math> where the probability that
a value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>
falls in a bin
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\alpha_{t-1},
\alpha_t)</annotation></semantics></math> may be directly estimated from
a standard classification model. The likelihood of this model may be
re-expressed in terms of the likelihood of a binary variable in a data
set expressed through a repeated measures structure. Specifically, this
re-formatting procedure is carried out by creating a data set in which
any given observation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>i</mi></msub><annotation encoding="application/x-tex">A_i</annotation></semantics></math>
appears (repeatedly) for as many intervals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\alpha_{t-1}, \alpha_t)</annotation></semantics></math>
that there are prior to the interval to which the observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
belongs. A new binary outcome variable, indicating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A_i \in
[\alpha_{t-1}, \alpha_t)</annotation></semantics></math>, is recorded as
part of this new data structure. With the re-formatted data, a pooled
hazard regression, spanning the support of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is then executed. Finally, the conditional density estimator
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>α</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mi>ℙ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mi>t</mi></msub><mo>−</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
   g_{n, \alpha}(a \mid W) = \frac{\mathbb{P}(a \in [\alpha_{t-1}, \alpha_t)
      \mid W)}{(\alpha_t - \alpha_{t-1})},
\end{equation*}</annotation></semantics></math> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>≤</mo><mi>a</mi><mo>≤</mo><msub><mi>α</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_{t-1} \leq a \le \alpha_t</annotation></semantics></math>,
may be constructed. As part of this procedure, the hazard estimates are
mapped to density estimates through rescaling of the estimates by the
bin size
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>t</mi></msub><mo>−</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha_t - \alpha_{t-1}</annotation></semantics></math>).</p>
<p>In its original proposal, a key element of this procedure was the use
of any arbitrary classification procedure for estimating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℙ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{P}(a \in
[\alpha_{t-1}, \alpha_t) \mid W)</annotation></semantics></math>,
facilitating the incorporation of flexible, data adaptive estimators. We
alter this proposal in two ways,</p>
<ol style="list-style-type: decimal">
<li>replacing the arbitrary estimator of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℙ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>α</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{P}(a \in [\alpha_{t-1},
\alpha_t) \mid W)</annotation></semantics></math> with HAL regression,
and</li>
<li>accommodating the use of sample-level weights, making it possible
for the resultant conditional density estimator to achieve a convergence
rate with respect to a loss-based dissimilarity of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><msup><mi>n</mi><mrow><mi>−</mi><mn>1</mn><mi>/</mi><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\approx n^{-1/3}</annotation></semantics></math>
under assumptions.</li>
</ol>
<p>Our procedure alters the HAL regression function to use a loss
function tailored for estimation of the hazard, invoking
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℓ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\ell_1</annotation></semantics></math>-penalization
in a manner consistent with this loss.</p>
</div>
<div class="section level2">
<h2 id="example-conditional-density-estimation">Example: Conditional density estimation<a class="anchor" aria-label="anchor" href="#example-conditional-density-estimation"></a>
</h2>
<p>First, let’s load a few required packages and set a seed for our
example.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://codex.nimahejazi.org/haldensify/">haldensify</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">75681</span><span class="op">)</span></span></code></pre></div>
<p>Next, we’ll generate a simple simulated dataset. The function
<code>make_example_data</code>, defined below, generates a baseline
covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and a continuous treatment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
whose mean is a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">make_example_data</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n_obs</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">W</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n_obs</span>, <span class="op">-</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span></span>
<span>  <span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n_obs</span>, mean <span class="op">=</span> <span class="va">W</span>, sd <span class="op">=</span> <span class="fl">0.25</span><span class="op">)</span></span>
<span>  <span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/as.data.table.html" class="external-link">as.data.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A</span>, W <span class="op">=</span> <span class="va">W</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Now, let’s simulate our data and take a quick look at it:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># number of observations in our simulated dataset</span></span>
<span><span class="va">n_obs</span> <span class="op">&lt;-</span> <span class="fl">200</span></span>
<span><span class="op">(</span><span class="va">example_data</span> <span class="op">&lt;-</span> <span class="fu">make_example_data</span><span class="op">(</span><span class="va">n_obs</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##               A           W</span></span>
<span><span class="co">##           &lt;num&gt;       &lt;num&gt;</span></span>
<span><span class="co">##   1:  2.3063922  2.24687273</span></span>
<span><span class="co">##   2:  0.9297479  0.91025531</span></span>
<span><span class="co">##   3: -3.2443382 -2.98696024</span></span>
<span><span class="co">##   4: -0.1842217 -0.01204378</span></span>
<span><span class="co">##   5:  3.2756387  3.59166824</span></span>
<span><span class="co">##  ---                       </span></span>
<span><span class="co">## 196:  0.4250425  0.43070281</span></span>
<span><span class="co">## 197:  1.0606211  1.35836156</span></span>
<span><span class="co">## 198:  2.2820014  2.34814939</span></span>
<span><span class="co">## 199: -2.9015290 -3.05240270</span></span>
<span><span class="co">## 200: -3.2334017 -3.52716556</span></span></code></pre>
<p>Next, we’ll fit our pooled hazards conditional density estimator via
the <code>haldensify</code> wrapper function. Based on underlying theory
and simulation experiments, we recommend setting a relatively large
number of bins and using a binning strategy that accommodates creating
such a large number of bins.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">haldensify_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/haldensify.html">haldensify</a></span><span class="op">(</span></span>
<span>  A <span class="op">=</span> <span class="va">example_data</span><span class="op">$</span><span class="va">A</span>,</span>
<span>  W <span class="op">=</span> <span class="va">example_data</span><span class="op">$</span><span class="va">W</span>,</span>
<span>  n_bins <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">6</span>, <span class="fl">8</span><span class="op">)</span>,</span>
<span>  grid_type <span class="op">=</span> <span class="st">"equal_range"</span>,</span>
<span>  lambda_seq <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.1</span>, <span class="op">-</span><span class="fl">10</span>, length <span class="op">=</span> <span class="fl">300</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="co"># the following are passed to hal9001::fit_hal() internally</span></span>
<span>  max_degree <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  reduce_basis <span class="op">=</span> <span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">n_obs</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Having constructed the conditional density estimator, we can examine
the empirical risk over the grid of choices of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math>
regularization parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.
To do this, we can simply call the available <code>plot</code> method,
which uses the cross-validated conditional density fits in the
<code>cv_tuning_results</code> slot of the <code>haldensify</code>
object. For example,</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p_risk</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">haldensify_fit</span><span class="op">)</span></span>
<span><span class="va">p_risk</span></span></code></pre></div>
<p><img src="intro_haldensify_files/figure-html/plot_risk_haldensify-1.png" alt="CV-risk of regularized conditional density estimators" width="700"></p>
<p>Finally, we can predict the conditional density over the grid of
observed values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
across different elements of the support
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.
We do this using the <code>predict</code> method of
<code>haldensify</code> and plot the results below.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># predictions to recover conditional density of A|W</span></span>
<span><span class="va">new_a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">4</span>, <span class="fl">4</span>, by <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span></span>
<span><span class="va">new_dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/as.data.table.html" class="external-link">as.data.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>  a <span class="op">=</span> <span class="va">new_a</span>,</span>
<span>  w_neg <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">new_a</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  w_zero <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">new_a</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  w_pos <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">new_a</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">new_dat</span><span class="op">[</span>, <span class="va">pred_w_neg</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">haldensify_fit</span>,</span>
<span>  new_A <span class="op">=</span> <span class="va">new_dat</span><span class="op">$</span><span class="va">a</span>,</span>
<span>  new_W <span class="op">=</span> <span class="va">new_dat</span><span class="op">$</span><span class="va">w_neg</span></span>
<span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">new_dat</span><span class="op">[</span>, <span class="va">pred_w_zero</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">haldensify_fit</span>,</span>
<span>  new_A <span class="op">=</span> <span class="va">new_dat</span><span class="op">$</span><span class="va">a</span>,</span>
<span>  new_W <span class="op">=</span> <span class="va">new_dat</span><span class="op">$</span><span class="va">w_zero</span></span>
<span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">new_dat</span><span class="op">[</span>, <span class="va">pred_w_pos</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">haldensify_fit</span>,</span>
<span>  new_A <span class="op">=</span> <span class="va">new_dat</span><span class="op">$</span><span class="va">a</span>,</span>
<span>  new_W <span class="op">=</span> <span class="va">new_dat</span><span class="op">$</span><span class="va">w_pos</span></span>
<span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co"># visualize results</span></span>
<span><span class="va">dens_dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/melt.data.table.html" class="external-link">melt</a></span><span class="op">(</span><span class="va">new_dat</span>,</span>
<span>  id <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">)</span>,</span>
<span>  measure.vars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"pred_w_pos"</span>, <span class="st">"pred_w_zero"</span>, <span class="st">"pred_w_neg"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">p_dens</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">dens_dat</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">a</span>, y <span class="op">=</span> <span class="va">value</span>, colour <span class="op">=</span> <span class="va">variable</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html" class="external-link">geom_line</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_function.html" class="external-link">stat_function</a></span><span class="op">(</span></span>
<span>    fun <span class="op">=</span> <span class="va">dnorm</span>, args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="op">-</span><span class="fl">2</span>, sd <span class="op">=</span> <span class="fl">0.25</span><span class="op">)</span>,</span>
<span>    colour <span class="op">=</span> <span class="st">"blue"</span>, linetype <span class="op">=</span> <span class="st">"dashed"</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_function.html" class="external-link">stat_function</a></span><span class="op">(</span></span>
<span>    fun <span class="op">=</span> <span class="va">dnorm</span>, args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="fl">0</span>, sd <span class="op">=</span> <span class="fl">0.25</span><span class="op">)</span>,</span>
<span>    colour <span class="op">=</span> <span class="st">"darkgreen"</span>, linetype <span class="op">=</span> <span class="st">"dashed"</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_function.html" class="external-link">stat_function</a></span><span class="op">(</span></span>
<span>    fun <span class="op">=</span> <span class="va">dnorm</span>, args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="fl">2</span>, sd <span class="op">=</span> <span class="fl">0.25</span><span class="op">)</span>,</span>
<span>    colour <span class="op">=</span> <span class="st">"red"</span>, linetype <span class="op">=</span> <span class="st">"dashed"</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span></span>
<span>    x <span class="op">=</span> <span class="st">"Observed value of W"</span>,</span>
<span>    y <span class="op">=</span> <span class="st">"Estimated conditional density"</span>,</span>
<span>    title <span class="op">=</span> <span class="st">"Conditional density estimates g(A|W)"</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html" class="external-link">theme</a></span><span class="op">(</span>legend.position <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span><span class="va">p_dens</span></span></code></pre></div>
<p><img src="intro_haldensify_files/figure-html/plot_haldensify-1.png" alt="Estimated conditional density of A|W for several choices of W" width="700"></p>
<p>In the above example, we generate synthetic data along a grid of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and three values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>−</mi><mn>2</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>+</mi><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">W \in \{-2, 0, +2\}</annotation></semantics></math>),
representing distinct groups/strata with respect to the covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.
Using this data, we use the trained <code>haldensify</code> model to
predict the density of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
conditional on the paired value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>,
yielding estimates of the conditional density for each of these three
hypothetical strata of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.
The resultant figure depicts the estimated conditional density as
colored points (blue for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>−</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">W = -2</annotation></semantics></math>,
green for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">W = 0</annotation></semantics></math>,
and red for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>+</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">W = +2</annotation></semantics></math>),
and the theoretical density for each group as smooth curves (using
<code>ggplot2</code>’s <code><a href="https://ggplot2.tidyverse.org/reference/geom_function.html" class="external-link">stat_function()</a></code>). For each group,
the differences between the estimated conditional densities and the
theoretical densities can be taken as indicative of the quality of the
<code>haldensify</code> estimator in this example. Overall, the
<code>haldensify</code> estimator appears to recover the underlying
density of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
best for the group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">W = 0</annotation></semantics></math>,
with slightly degraded performance for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>−</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">W = -2</annotation></semantics></math>,
which degrades further for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>+</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">W = +2</annotation></semantics></math>.
The <code>haldensify</code> conditional density estimator has been used
to estimate the generalized propensity score in applications of the
methodology described in <span class="citation">Hejazi et al.
(2020)</span>.</p>
</div>
<div class="section level2">
<h2 id="nonparametric-inverse-probability-weighted-estimation">Nonparametric inverse probability weighted estimation<a class="anchor" aria-label="anchor" href="#nonparametric-inverse-probability-weighted-estimation"></a>
</h2>
<p>As mentioned above, the generalized propensity score is a critical
ingredient in evaluating causal effects for continuous treatments. A
popular framework for defining and evaluating such causal effects is
that of modified treatment policies <span class="citation">(Haneuse and
Rotnitzky 2013; Dı́az and van der Laan 2018; Hejazi et al. 2022)</span>,
which define interventions that shift (or modify) the treatment. For
example, in a setting with a continuous treatment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
in which we additionally collect baseline covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and an outcome measurement
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
(so that the data on a given unit is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>W</mi><mo>,</mo><mi>A</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O = (W, A, Y)</annotation></semantics></math>),
we could consider an intervention that sets the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>W</mi><mo>;</mo><mi>δ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>A</mi><mo>+</mo><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">d(A,W; \delta) = A + \delta(W)</annotation></semantics></math>,
for a user-defined function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>W</mi><mo>;</mo><mi>δ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">d(A,W;\delta)</annotation></semantics></math>
indexed by a function (or scalar)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>.
This intervention regime is a simple example of a modified treatment
policy (MTP); it can be thought of mapping the observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
to a counterfactual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>δ</mi></msub><annotation encoding="application/x-tex">A_{\delta}</annotation></semantics></math>
that is itself an additive shift of the natural value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
The counterfactual mean of such an intervention would be expressed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mo stretchy="false" form="prefix">[</mo><mi>Y</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>A</mi><mi>δ</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y(A_{\delta})]</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>A</mi><mi>δ</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Y(A_{\delta})</annotation></semantics></math>
is the potential outcome that would be observed had the treatment taken
the value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>δ</mi></msub><annotation encoding="application/x-tex">A_{\delta}</annotation></semantics></math>.
Both <span class="citation">Haneuse and Rotnitzky (2013)</span> and
<span class="citation">Dı́az and van der Laan (2018)</span> proposed
substitution, inverse probability weighted (IPW), and doubly robust
estimators of a statistical functional
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
that identifies this counterfactual mean under standard assumptions.
Doubly robust estimators of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
are implemented in the <code>txshift</code> <code>R</code> package <span class="citation">(Hejazi and Benkeser 2020, 2022)</span>; such
estimation frameworks are usually necessary in order to take advantage
of flexible estimators of nuisance parameters.</p>
<p>Despite the popularity of doubly robust estimation procedures, IPW
estimators can be modified to accommodate data adaptive estimation of
the (generalized) propensity score. Such nonparametric IPW estimators,
based on HAL, have been described by <span class="citation">Ertefaie,
Hejazi, and van der Laan (2022)</span> in the context of binary
treatments, and by <span class="citation">Hejazi et al. (2022)</span>
for continuous treatments. The IPW estimator of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ψ</mi><mrow><mi>n</mi><mo>,</mo><mtext mathvariant="normal">IPW</mtext></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>g</mi><mo accent="true">̃</mo></mover><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo><mi>/</mi><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>∣</mo><mi>W</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\psi_{n,\text{IPW}} = \{\tilde{g}_{n,A}(A \mid W) / g_{n,A}(A \mid
W)\} Y</annotation></semantics></math>, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A}</annotation></semantics></math>
is an estimator of the generalized propensity score (e.g., as produced
by <code><a href="../reference/haldensify.html">haldensify()</a></code>) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>g</mi><mo accent="true">̃</mo></mover><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">\tilde{g}_{n,A}</annotation></semantics></math>
is this quantity evaluated at the post-intervention value of the
treatment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>δ</mi></msub><annotation encoding="application/x-tex">A_{\delta}</annotation></semantics></math>.
Usually,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A}</annotation></semantics></math>
must be estimated via parametric modeling strategies in order for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ψ</mi><mrow><mi>n</mi><mo>,</mo><mtext mathvariant="normal">IPW</mtext></mrow></msub><annotation encoding="application/x-tex">\psi_{n,\text{IPW}}</annotation></semantics></math>
to achieve desirable asymptotic properties (unbiasedness, efficiency);
however, when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A}</annotation></semantics></math>
is estimated flexibly, sieve estimation strategies (undersmoothing) may
be used to select an estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A}</annotation></semantics></math>,
from among an appropriate class, that allows for optimal estimation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>.
This issue arises in part because strategies for optimal selection of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A}</annotation></semantics></math>
(e.g., cross-validation) optimize for estimation of the conditional
density, ignoring the fact that it is only a nuisance parameter in the
process of IPW estimation. When <code><a href="../reference/haldensify.html">haldensify()</a></code> is used for
this purpose, a family of conditional density estimators
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi><mo>,</mo><mi>λ</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A,\lambda}</annotation></semantics></math>,
indexed by the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℓ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\ell_1</annotation></semantics></math>
regularization term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>,
are generated, with cross-validation used to select an optimal estimator
from among this trajectory in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.
We saw this above when we visualized the empirical risk profile of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mrow><mi>n</mi><mo>,</mo><mi>A</mi></mrow></msub><annotation encoding="application/x-tex">g_{n,A}</annotation></semantics></math>.
While empirical risk minimization based on the framework of
cross-validated loss-based estimation is appropriate for optimally
estimating the generalized propensity score, the selected estimator will
fail to yield an IPW estimator with desirable asymptotic properties;
undersmoothing must be used to select a more appropriate estimator. The
<code>haldensify</code> package implements nonparametric IPW estimators
that incorporate undersmoothing in the <code><a href="../reference/ipw_shift.html">ipw_shift()</a></code>
function, the use of which we demonstrate below.</p>
</div>
<div class="section level2">
<h2 id="example-nonparametric-ipw-estimation">Example: Nonparametric IPW estimation<a class="anchor" aria-label="anchor" href="#example-nonparametric-ipw-estimation"></a>
</h2>
<p>To begin, we set up a new data-generating process and simulate data
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">n =
200</annotation></semantics></math> units from it. We will aim to
estimate the counterfactual mean of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
under an MTP that shifts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\delta = 2</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># set up data-generating process</span></span>
<span><span class="va">make_example_data</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n_obs</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">W</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n_obs</span>, <span class="fl">1</span>, <span class="fl">4</span><span class="op">)</span></span>
<span>  <span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html" class="external-link">rpois</a></span><span class="op">(</span><span class="va">n_obs</span>, <span class="fl">2</span> <span class="op">*</span> <span class="va">W</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="va">n_obs</span>, <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Logistic.html" class="external-link">plogis</a></span><span class="op">(</span><span class="fl">2</span> <span class="op">-</span> <span class="va">A</span> <span class="op">+</span> <span class="va">W</span> <span class="op">+</span> <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdatatable.gitlab.io/data.table/reference/as.data.table.html" class="external-link">as.data.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>Y <span class="op">=</span> <span class="va">Y</span>, A <span class="op">=</span> <span class="va">A</span>, W <span class="op">=</span> <span class="va">W</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># generate data and take a look</span></span>
<span><span class="op">(</span><span class="va">dat_obs</span> <span class="op">&lt;-</span> <span class="fu">make_example_data</span><span class="op">(</span>n_obs <span class="op">=</span> <span class="fl">200</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          Y     A        W</span></span>
<span><span class="co">##      &lt;int&gt; &lt;int&gt;    &lt;num&gt;</span></span>
<span><span class="co">##   1:     0    11 2.817789</span></span>
<span><span class="co">##   2:     1     7 3.086448</span></span>
<span><span class="co">##   3:     1     2 1.411537</span></span>
<span><span class="co">##   4:     1     6 2.913294</span></span>
<span><span class="co">##   5:     1     5 3.374974</span></span>
<span><span class="co">##  ---                     </span></span>
<span><span class="co">## 196:     1     2 1.347253</span></span>
<span><span class="co">## 197:     1     3 1.383259</span></span>
<span><span class="co">## 198:     1     2 1.103883</span></span>
<span><span class="co">## 199:     1     3 1.660835</span></span>
<span><span class="co">## 200:     1     5 2.183518</span></span></code></pre>
<p>With this dataset, we can now simply call the
<code><a href="../reference/ipw_shift.html">ipw_shift()</a></code> function, providing arguments that specify the
causal effect of interest (<code>delta = 2</code>) and tuning parameters
for estimating the generalized propensity score
(<code>lambda_seq</code>, <code>cv_folds</code>, <code>n_bins</code>).
The <code>selector_type</code> argument specifies the type of
undersmoothing to be used to select an appropriate IPW estimator (from
among a sequence in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>);
setting the option <code>selector_type = "all"</code> simply returns IPW
estimators for each of the selectors implemented. For a formal
description of the selectors and numerical experiments examining their
performance, see <span class="citation">Hejazi et al. (2022)</span>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est_ipw</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ipw_shift.html">ipw_shift</a></span><span class="op">(</span></span>
<span>  W <span class="op">=</span> <span class="va">dat_obs</span><span class="op">$</span><span class="va">W</span>, A <span class="op">=</span> <span class="va">dat_obs</span><span class="op">$</span><span class="va">A</span>, Y <span class="op">=</span> <span class="va">dat_obs</span><span class="op">$</span><span class="va">Y</span>,</span>
<span>  delta <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  cv_folds <span class="op">=</span> <span class="fl">5L</span>,</span>
<span>  n_bins <span class="op">=</span> <span class="fl">4L</span>,</span>
<span>  bin_type <span class="op">=</span> <span class="st">"equal_range"</span>,</span>
<span>  selector_type <span class="op">=</span> <span class="st">"all"</span>,</span>
<span>  lambda_seq <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">10</span>, length <span class="op">=</span> <span class="fl">500L</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="co"># arguments passed to hal9001::fit_hal()</span></span>
<span>  max_degree <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  reduce_basis <span class="op">=</span> <span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">n_obs</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/confint.html" class="external-link">confint</a></span><span class="op">(</span><span class="va">est_ipw</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 6 × 8</span></span></span>
<span><span class="co">##   lwr_ci   psi upr_ci se_est type           l1_norm lambda_idx gn_nbins</span></span>
<span><span class="co">##    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>            <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>      <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;int&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>  0.570 0.668  0.753 0.046<span style="text-decoration: underline;">9</span> gcv               10.3        254        4</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">2</span>  0.570 0.668  0.753 0.046<span style="text-decoration: underline;">9</span> dcar_tol          10.3        254        4</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">3</span>  0.561 0.657  0.741 0.046<span style="text-decoration: underline;">4</span> dcar_min          23.7        295        4</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">4</span>  0.564 0.658  0.740 0.045<span style="text-decoration: underline;">2</span> lepski_plateau    30.7        301        4</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">5</span>  0.561 0.657  0.741 0.046<span style="text-decoration: underline;">4</span> smooth_plateau    23.7        295        4</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">6</span>  0.561 0.657  0.741 0.046<span style="text-decoration: underline;">4</span> hybrid_plateau    23.7        295        4</span></span></code></pre>
<p>The <code><a href="https://rdrr.io/r/stats/confint.html" class="external-link">confint()</a></code> method used above simply creates
confidence intervals (95%, by default) for each of the IPW estimates
returned. Examining the output, we can see that the IPW estimator based
on cross-validation (<code>"gcv"</code>) differs from that based on
minimization of an important criterion from semiparametric efficiency
theory (<code>"dcar_min"</code>). These estimators have different
asymptotic properties, with the latter guaranteed to solve an estimating
function required for the characterization of asymptotically efficient
estimators.</p>
<div class="section level3">
<h3 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h3>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-diaz2011super" class="csl-entry">
Dı́az, Iván, and Mark J van der Laan. 2011. <span>“Super Learner Based
Conditional Density Estimation with Application to Marginal Structural
Models.”</span> <em>International Journal of Biostatistics</em> 7 (1):
1–20. <a href="https://doi.org/10.2202/1557-4679.1356" class="external-link">https://doi.org/10.2202/1557-4679.1356</a>.
</div>
<div id="ref-diaz2018stochastic" class="csl-entry">
———. 2018. <span>“Stochastic Treatment Regimes.”</span> In <em>Targeted
Learning in Data Science: Causal Inference for Complex Longitudinal
Studies</em>, 167–80. Springer. <a href="https://doi.org/10.1007/978-3-319-65304-4_14" class="external-link">https://doi.org/10.1007/978-3-319-65304-4_14</a>.
</div>
<div id="ref-ertefaie2020nonparametric" class="csl-entry">
Ertefaie, Ashkan, Nima S Hejazi, and Mark J van der Laan. 2022.
<span>“Nonparametric Inverse-Probability-Weighted Estimators Based on
the Highly Adaptive Lasso.”</span> <em>Biometrics</em> (in press). <a href="https://doi.org/10.1111/biom.13719" class="external-link">https://doi.org/10.1111/biom.13719</a>.
</div>
<div id="ref-haneuse2013estimation" class="csl-entry">
Haneuse, Sebastian, and A Rotnitzky. 2013. <span>“Estimation of the
Effect of Interventions That Modify the Received Treatment.”</span>
<em>Statistics in Medicine</em> 32 (30): 5260–77. <a href="https://doi.org/10.1002/sim.5907" class="external-link">https://doi.org/10.1002/sim.5907</a>.
</div>
<div id="ref-hejazi2020txshift-joss" class="csl-entry">
Hejazi, Nima S, and David C Benkeser. 2020. <span>“<span class="nocase">txshift</span>: Efficient Estimation of the Causal
Effects of Stochastic Interventions in <span>R</span>.”</span>
<em>Journal of Open Source Software</em> 5 (54): 2447. <a href="https://doi.org/10.21105/joss.02447" class="external-link">https://doi.org/10.21105/joss.02447</a>.
</div>
<div id="ref-hejazi2022txshift-rpkg" class="csl-entry">
———. 2022. <em><span><code>txshift</code></span>: Efficient Estimation
of the Causal Effects of Stochastic Interventions</em>. <a href="https://doi.org/10.5281/zenodo.4070042" class="external-link">https://doi.org/10.5281/zenodo.4070042</a>.
</div>
<div id="ref-hejazi2022efficient" class="csl-entry">
Hejazi, Nima S, David Benkeser, Iván Dı́az, and Mark J van der Laan.
2022. <span>“Efficient Estimation of Modified Treatment Policy Effects
Based on the Generalized Propensity Score.”</span> <em>arXiv</em>. <a href="https://arxiv.org/abs/2205.05777" class="external-link">https://arxiv.org/abs/2205.05777</a>.
</div>
<div id="ref-hejazi2020efficient" class="csl-entry">
Hejazi, Nima S, Mark J van der Laan, Holly E Janes, Peter B Gilbert, and
David C Benkeser. 2020. <span>“Efficient Nonparametric Inference on the
Effects of Stochastic Interventions Under Two-Phase Sampling, with
Applications to Vaccine Efficacy Trials.”</span> <em>Biometrics</em> 77
(4): 1241–53. <a href="https://doi.org/10.1111/biom.13375" class="external-link">https://doi.org/10.1111/biom.13375</a>.
</div>
<div id="ref-hirano2004propensity" class="csl-entry">
Hirano, Keisuke, and Guido W Imbens. 2004. <span>“The Propensity Score
with Continuous Treatments.”</span> <em>Applied Bayesian Modeling and
Causal Inference from Incomplete-Data Perspectives</em> 226164: 73–84.
</div>
<div id="ref-imai2004causal" class="csl-entry">
Imai, Kosuke, and David A Van Dyk. 2004. <span>“Causal Inference with
General Treatment Regimes: Generalizing the Propensity Score.”</span>
<em>Journal of the American Statistical Association</em> 99 (467):
854–66.
</div>
<div id="ref-zhu2015boosting" class="csl-entry">
Zhu, Yeying, Donna L Coffman, and Debashis Ghosh. 2015. <span>“A
Boosting Algorithm for Estimating Generalized Propensity Scores with
Continuous Treatments.”</span> <em>Journal of Causal Inference</em> 3
(1): 25–40. <a href="https://doi.org/10.1515/jci-2014-0022" class="external-link">https://doi.org/10.1515/jci-2014-0022</a>.
</div>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Nima Hejazi, David Benkeser, Mark van der Laan.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
